# [카드뭉치]
- 링크 :  https://programmers.co.kr/learn/courses/30/lessons/159994

```
#큐 #카드게임 #시뮬레이션 #투포인터
```

## 풀이 과정

### 핵심 아이디어
-

### 접근 방법
1.
2.

### 코드

```python
def solution():
    pass
```

## 회고

### 배운 점
- cards1과 cards2의 길이가 최대 10이므로  리스트의 pop() 함수를 사용해도 시간 복잡도에 큰 영향이 없음
- 실제 큐를 사용하지 않더라도 개념적인 큐의 동작 방식을 이해하고 있으면 문제 해결에 도움이 됨

### 어려웠던 부분
-

### 개선할 점
- goal에 대한 인덱싱 처리를 하지 않아도 반복문을 완료하면 goal의 모든 단어를 사용했는지 알 수 있으므로 불필요한 인덱싱 처리를 제거함

## 평가

### 개선할 점

1. **불필요한 변수 `matched` 제거**
   - 현재 코드는 `matched` 변수로 매칭된 단어 수를 카운팅하지만, 이는 로직상 불필요합니다
   - 반복문에서 매칭 실패 시 즉시 `'No'`를 반환하므로, 반복문이 끝까지 실행되었다는 것 자체가 모든 goal을 성공적으로 매칭했다는 의미입니다
   - 최종 return문을 `return 'Yes' if matched == len(goal) else 'No'` 대신 단순히 `return 'Yes'`로 작성할 수 있습니다

2. **인덱스 범위 체크 방식 개선 가능**
   - `len(cards1) > c1idx` 대신 `c1idx < len(cards1)`이 더 자연스러운 표현입니다 (일반적인 인덱스 경계 검사 패턴)
   - 또는 `c1idx < len(cards1) and cards1[c1idx] == want`처럼 순서를 바꾸면 가독성이 향상됩니다

3. **문서화 부족**
   - README.md의 핵심 아이디어, 접근 방법, 코드 섹션이 비어있습니다
   - 복잡도 분석이 누락되어 있습니다 (시간: O(n), 공간: O(1))
   - 문제 링크와 태그 정보가 없습니다

### 잘한 점

1. **투 포인터 패턴의 정확한 이해**
   - 두 개의 독립적인 인덱스(`c1idx`, `c2idx`)를 사용하여 각 카드 뭉치의 현재 위치를 추적하는 방식이 매우 적절합니다
   - 큐 문제의 본질(FIFO)을 인덱스만으로 효율적으로 구현했습니다

2. **조기 종료 최적화**
   - 매칭 실패 시 즉시 `'No'`를 반환하여 불필요한 순회를 방지했습니다
   - 이는 worst case에서도 효율적인 실행을 보장합니다

3. **명확한 주석**
   - 코드 상단의 주석(3-6줄)이 알고리즘의 핵심 로직을 잘 설명하고 있습니다
   - "둘 중에 사용 가능한 카드가 있으면 해당 카드 인덱스 증가"라는 표현이 직관적입니다

4. **효율적인 시간 복잡도**
   - O(n) 시간 복잡도로 goal의 길이만큼만 순회합니다
   - 추가 자료구조를 사용하지 않아 공간 복잡도도 O(1)로 최적입니다

5. **간결한 구현**
   - deque 같은 추가 자료구조 없이 인덱스만으로 큐의 동작을 구현하여 메모리 효율적입니다

### 다른 응용 방안

1. **실제 큐 자료구조 활용 (collections.deque)**
   ```python
   from collections import deque
   def solution(cards1, cards2, goal):
       q1, q2 = deque(cards1), deque(cards2)
       for word in goal:
           if q1 and q1[0] == word:
               q1.popleft()
           elif q2 and q2[0] == word:
               q2.popleft()
           else:
               return 'No'
       return 'Yes'
   ```
   - 가독성은 향상되지만 추가 공간 복잡도 O(n+m) 발생

2. **3개 이상의 카드 뭉치로 일반화**
   ```python
   def solution_general(card_decks, goal):
       indices = [0] * len(card_decks)
       for word in goal:
           found = False
           for i, deck in enumerate(card_decks):
               if indices[i] < len(deck) and deck[indices[i]] == word:
                   indices[i] += 1
                   found = True
                   break
           if not found:
               return 'No'
       return 'Yes'
   ```

3. **카드 선택 순서 조합 문제로 확장**
   - 여러 카드를 동시에 선택할 수 있는 경우
   - 백트래킹/DFS로 모든 조합 탐색

### 종합 평가

이 풀이는 큐의 FIFO 특성을 인덱스 기반으로 효율적으로 구현한 좋은 사례입니다. 투 포인터 패턴을 정확히 이해하고 있으며, 조기 종료 최적화를 통해 불필요한 연산을 제거했습니다.

다만, `matched` 변수는 로직상 불필요합니다. 반복문에서 실패 시 즉시 반환하므로, 반복문 완료 자체가 성공을 의미합니다. 이를 제거하면 코드가 더 간결해지고 의도가 명확해집니다. 또한 README.md의 풀이 과정과 복잡도 분석이 누락되어 있어, 학습 기록으로서의 가치를 충분히 활용하지 못하고 있습니다.

코딩 테스트 관점에서, 이 풀이는 시간/공간 복잡도가 최적이며 구현도 간결합니다. 하지만 실전에서는 인덱스 범위 체크 순서를 자연스럽게 작성하고(`c1idx < len(cards1)` 형태), 불필요한 변수를 제거하여 코드의 의도를 더 명확히 전달하는 것이 중요합니다.

---
**복잡도**: 시간 O(n), 공간 O(1) - n은 goal의 길이
**풀이 날짜**: 2025-01-06
