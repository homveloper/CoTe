# [3차] 압축
- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/17684

```
#해시 #문자열 #LZW #구현
```

## 풀이 과정

### 핵심 아이디어
- LZW 압축 알고리즘 구현
- 사전에 등록된 문자열 중 가장 긴 것을 찾아 색인 번호 출력
- 다음 글자를 포함한 새로운 문자열을 사전에 등록

### 접근 방법
1. A-Z를 사전에 초기화 (1-26번)
2. 현재 위치에서 뒤에서부터 탐색하여 사전에 등록된 가장 긴 문자열 찾기
3. 해당 문자열의 색인 번호를 출력 배열에 추가
4. 다음 글자를 포함한 문자열을 사전에 추가
5. 입력 문자열의 끝까지 반복

## 회고

### 배운 점
- LZW 압축 알고리즘의 동작 원리를 이해하게 됨.
- 딕셔너리를 활용한 문자열 탐색 및 추가 방법 숙달.

### 어려웠던 부분
- j 범위를 지정하는것과,  긴 문자열 부터 탐색하는 방법이 어려웠음.

### 개선할 점
- while문 및  인덱스 기반 처리 능력이 부족하여 개선이 필요함.

## 평가

## 개선할 점

### 1. 시간 복잡도 비효율성 ⚠️ 중요
현재 구현은 **O(N²)** 복잡도입니다:
```python
for j in range(len(msg), i, -1):  # 매번 최대 N번 반복
    if msg[i:j] not in dictionary:  # O(1) 해시 조회
        continue
```

**더 효율적인 O(N) 접근법**:
```python
# 뒤에서부터 탐색하는 대신, 앞에서부터 확장하기
w = msg[i]
while i + len(w) < len(msg) and w + msg[i + len(w)] in dictionary:
    w += msg[i + len(w)]
```

입력 크기가 1000 이하라서 통과하지만, 실전에서는 효율적인 알고리즘이 더 중요합니다.

### 2. range() 사용의 비직관성
사용자가 언급한 "변수 j의 범위 처리" 문제:
```python
for j in range(len(msg), i, -1):  # len(msg)부터 i+1까지 역순
    if msg[i:j] not in dictionary:
        continue
```

**문제점**:
- `range(len(msg), i, -1)`은 헷갈리기 쉬움
- `msg[i:j]`에서 j가 len(msg)일 때 실제로는 끝까지 슬라이싱
- 역순 탐색의 의도는 좋지만 코드 가독성이 떨어짐

**개선 방안**:
```python
# 명확한 순회 (i+1부터 len(msg)+1까지)
for length in range(len(msg) - i, 0, -1):
    substring = msg[i:i+length]
    if substring in dictionary:
        # ...
```

### 3. 변수명 개선
- `idx`: `next_index` 또는 `dict_size`가 더 명확
- `i`, `j`: `current_pos`, `end_pos` 등이 더 직관적

### 4. 엣지 케이스 고려 부족
- 입력이 빈 문자열인 경우 처리 누락 (문제 제약상 발생하지 않지만)
- `msg = ""`일 때 `while i < len(msg)`는 바로 종료되지만 명시적 체크가 좋음

## 잘한 점

### 1. 딕셔너리 초기화 방식 ✨
```python
dictionary = { chr(i+65) : i+1 for i in range(0,26)}
```
딕셔너리 컴프리헨션을 활용한 간결한 초기화가 훌륭합니다.

### 2. 문제 이해도
LZW 알고리즘의 핵심을 정확히 이해하고 구현했습니다:
- 사전에서 가장 긴 문자열 찾기
- 다음 문자를 포함한 새 문자열 등록
- 인덱스 누적

### 3. 슬라이싱 활용
`msg[i:j]`를 사용하여 부분 문자열을 효과적으로 추출했습니다.

### 4. 주석 작성
```python
# 입력에서 w를 제거 하는 대신 위치를 옮기기
```
알고리즘의 의도를 주석으로 명확히 했습니다.

## 다른 응용 방안

### 1. LZW 압축률 분석
- 원본 길이 대비 압축된 출력 길이 비교
- 어떤 패턴의 문자열이 압축에 유리한지 분석

### 2. 역압축 구현
- 압축된 인덱스 배열을 받아 원본 문자열 복원
- 사전을 동일하게 구축하며 디코딩

### 3. 실제 파일 압축
- 바이너리 데이터에 LZW 적용
- GIF 이미지 포맷에서 사용되는 LZW 변형 이해

### 4. 메모리 효율적인 사전 관리
- 사전 크기 제한 (예: 4096개)
- LRU 방식으로 오래된 항목 제거

## 다른 추천 문제

### 유사 문자열/압축 문제
- **프로그래머스 - 문자열 압축** (level 2): 반복 패턴 압축
- **프로그래머스 - 괄호 변환** (level 2): 문자열 재귀 처리
- **백준 9935 - 문자열 폭발**: 스택을 이용한 문자열 처리

### 해시/사전 활용 문제
- **프로그래머스 - 오픈채팅방** (level 2): 딕셔너리로 상태 관리
- **프로그래머스 - 베스트앨범** (level 3): 해시 + 정렬
- **백준 17219 - 비밀번호 찾기**: 기본 해시 활용

### 알고리즘 이해 심화
- **백준 1786 - 찾기**: KMP 알고리즘 (문자열 패턴 매칭)
- **백준 1305 - 광고**: 문자열 주기 찾기

## 종합 평가

**알고리즘 이해도**: LZW 압축의 핵심 원리를 정확히 이해하고 구현했습니다. 사전에 등록된 가장 긴 문자열을 찾고, 다음 문자를 포함한 문자열을 추가하는 로직이 올바릅니다.

**구현 방식의 선택**: 뒤에서부터 탐색하는 방식을 선택한 것은 "가장 긴 문자열 찾기"라는 목표를 달성하지만, **시간 복잡도 관점에서는 최적이 아닙니다**. 앞에서부터 확장하며 사전에 없을 때까지 찾는 방식이 O(N²)에서 O(N)으로 개선할 수 있습니다.

**사용자가 언급한 "변수 j의 범위 처리" 이슈**: `range(len(msg), i, -1)`은 파이썬의 range 동작을 정확히 이해해야 하는 부분입니다. 특히 슬라이싱 `msg[i:j]`와 결합될 때 j의 값이 의미하는 바가 직관적이지 않습니다. 이런 경우 **길이 기반 접근 (`length = j - i`)이나 명시적인 end_pos 변수**를 사용하면 가독성이 향상됩니다.

**개선 포인트**:
1. 시간 복잡도를 O(N)으로 최적화
2. range 사용을 더 직관적으로 변경
3. 변수명을 의미 있게 개선
4. 코드 리뷰 시 복잡도 분석 습관 들이기

**강점**: 딕셔너리 활용이 우수하고, 문제 핵심을 정확히 구현했습니다. 코딩 테스트에서는 정확성이 우선이지만, 효율성 향상을 위한 최적화 사고가 필요합니다.

---
**복잡도**: 시간 O(N²) / 공간 O(N) (사전 크기)
**풀이 날짜**:
