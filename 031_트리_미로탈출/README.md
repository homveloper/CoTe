# 미로 탈출
- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/159993

```
#BFS #그래프탐색 #상태공간탐색
```

## 풀이 과정

### 핵심 아이디어
- BFS를 사용한 최단 경로 탐색
- 레버를 당긴 상태와 당기지 않은 상태를 별도로 관리하는 3차원 상태 공간 탐색

### 접근 방법
1. S(시작점)에서 L(레버)까지의 최단 경로 찾기
2. L(레버)에서 E(출구)까지의 최단 경로 찾기
3. BFS로 (x, y, 레버 상태)를 추적하며 탐색

## 회고

### 배운 점
- 튜플을 적극 활용하여, 큐, 방문 처리 등에 구조체를 대신하여 사용 가능

### 어려웠던 부분
- 방문 처리에서  레버 당김 여부를 어떻게 표현할지 고민했던 점
- 큐에 저장하는 데이터에 좌표 외에 상태 정보를 어떻게 포함할지 고민했던 점

### 개선할 점
-  

## 평가

## 개선할 점

### 1. 비효율적인 조건문 (solution.py:62)
```python
# 현재 코드
if (0 <= nx < width and 0 <= ny < height) != True:
    continue

# 개선안
if not (0 <= nx < width and 0 <= ny < height):
    continue
```
- `!= True` 비교는 불필요하고 가독성을 떨어뜨립니다.
- Pythonic한 방식은 `not` 연산자를 직접 사용하는 것입니다.

### 2. 중복 큐 삽입 가능성
```python
# 현재: 방문 처리가 큐 삽입 이후
queue.append((nx,ny, count+1, 1))
visited.add(Trace(nx,ny,1))
```
- 현재 코드는 방문 체크 후 큐에 삽입하지만, 같은 노드가 여러 번 큐에 들어갈 수 있습니다.
- BFS에서는 큐에 넣기 **전**에 방문 처리를 하는 것이 일반적으로 더 효율적입니다.
- 다만 이 문제에서는 레버 상태가 다르면 다른 상태이므로 현재 구현도 동작합니다.

### 3. 자료구조 일관성 부족
- `visited`는 `Trace` dataclass 객체를 사용
- `queue`는 튜플 `(x, y, count, lever)`를 사용
- 둘 중 하나로 통일하면 코드의 일관성이 높아집니다.

**개선 예시:**
```python
# 옵션 1: 모두 튜플 사용
visited = set()  # (x, y, lever) 튜플 저장
queue = deque()  # (x, y, count, lever) 튜플 저장

# 옵션 2: dataclass 확장
@dataclass(frozen=True)
class State:
    x: int
    y: int
    count: int
    lever: int
```

### 4. 불필요한 dataclass import
- `dataclass`를 사용하고 있지만, 튜플만으로도 충분히 해결 가능한 문제입니다.
- 간단한 상태 저장에는 `(x, y, lever)` 튜플이 더 경량화되고 빠릅니다.

## 잘한 점

### 1. 상태 공간 탐색의 정확한 이해
- 레버를 당긴 상태/안 당긴 상태를 별도로 관리해야 한다는 핵심을 정확히 파악했습니다.
- `(x, y, lever)` 3차원 공간에서의 방문 처리는 이 문제의 핵심입니다.

### 2. BFS를 이용한 최단 경로 탐색
- 최단 경로 문제에 BFS를 적용한 것이 올바른 선택입니다.
- `count` 변수로 거리를 추적하며 첫 도착 시점이 최단 경로임을 보장합니다.

### 3. 명확한 종료 조건
```python
if x == end_x and y == end_y and lever == 1:
    return count
```
- 출구에 도착했을 때 레버를 당긴 상태인지 확인하는 조건이 명확합니다.

### 4. 방향 벡터 활용
```python
directions = [(1,0), (-1, 0), (0,1), (0,-1)]
```
- 4방향 탐색을 깔끔하게 처리했습니다.

## 다른 응용 방안

### 1. 다중 열쇠 문제로 확장
- 레버가 여러 개 있고, 특정 순서로 당겨야 하는 문제로 확장 가능
- 상태를 비트마스크로 관리: `(x, y, key_bitmask)`

### 2. 가중치가 있는 미로
- 각 칸마다 이동 비용이 다른 경우 다익스트라 알고리즘 적용
- `heapq`를 사용하여 최소 비용 경로 탐색

### 3. 3차원 미로 탐색
- z축이 추가된 3D 미로에서 `(x, y, z, lever)` 4차원 상태 공간 탐색

## 다른 추천 문제

### 비슷한 난이도의 BFS 문제
- **[프로그래머스] 게임 맵 최단거리** - 기본 BFS 최단 경로
- **[프로그래머스] 아이템 줍기** - 좌표 스케일링을 활용한 BFS
- **[백준] 2178번 미로 탐색** - 기본 BFS 연습
맵
### 상태 공간 탐색 확장 문제
- **[백준] 1697번 숨바꼭질** - 1차원 BFS
- **[백준] 13549번 숨바꼭질 3** - 0-1 BFS (가중치가 다른 경우)
- **[백준] 9019번 DSLR** - 상태 변환 BFS

### 비트마스킹 + BFS
- **[백준] 1194번 달이 차오른다, 가자.** - 열쇠와 문이 있는 미로 (비트마스크 활용)
- **[백준] 17836번 공주님을 구해라!** - 검을 획득하는 조건이 있는 미로

## 종합 평가

전반적으로 BFS와 상태 공간 탐색의 핵심 개념을 정확히 이해하고 구현한 풀이입니다. 특히 레버라는 상태 변수를 추가하여 3차원 방문 배열 개념을 적용한 점이 우수합니다.

다만 몇 가지 개선 여지가 있습니다:
1. **코드 일관성**: dataclass와 튜플을 혼용하기보다는 하나로 통일하는 것이 좋습니다. 특히 이 문제 수준에서는 튜플만으로도 충분하며, 불필요한 dataclass import를 제거하면 코드가 더 간결해집니다.
2. **Pythonic 작성법**: 조건문에서 `!= True` 같은 불필요한 비교를 피하고, `not` 연산자를 직접 사용하세요.
3. **성능 최적화**: BFS에서 방문 처리 시점을 큐 삽입 전으로 앞당기면 중복 탐색을 줄일 수 있습니다 (이 문제에서는 영향이 크지 않지만 좋은 습관입니다).

이 문제를 통해 **상태를 어떻게 정의하고 관리할 것인가**를 배웠다면, 다음 단계로는 비트마스킹을 활용한 복잡한 상태 관리 문제(예: 백준 1194번)를 도전해보는 것을 추천합니다. 이를 통해 상태 공간 탐색의 범위를 넓힐 수 있을 것입니다.

---
**복잡도**: O(N × M × 2) - N×M 크기의 맵을 레버 상태 2가지로 탐색
**풀이 날짜**: 2024-11-16

---

## 추가 학습

### 상태 공간 탐색 (State Space Search)

이 문제의 핵심은 **단순한 2차원 좌표가 아니라 상태(State)를 정의**하는 것입니다.

#### 상태의 정의
- 일반 미로: `(x, y)` - 2차원 상태
- 이 문제: `(x, y, lever)` - 3차원 상태
  - 같은 좌표라도 레버를 당긴 상태/안 당긴 상태는 **다른 상태**입니다.

#### 왜 3차원인가?
```python
# 잘못된 접근: 2차원 방문 처리
visited[y][x] = True  # ❌ 레버 상태를 구분하지 못함

# 올바른 접근: 3차원 방문 처리
visited[(x, y, 0)] = True  # 레버를 안 당긴 상태로 (x,y) 방문
visited[(x, y, 1)] = True  # 레버를 당긴 상태로 (x,y) 방문
```

같은 칸을 두 번 방문할 수 있습니다:
1. 레버를 당기기 전에 지나간 경우
2. 레버를 당긴 후 다시 지나가는 경우

### BFS와 최단 경로

#### BFS의 핵심 성질
- **같은 가중치(여기서는 1칸 이동 = 비용 1)**를 가진 그래프에서 최단 경로를 보장합니다.
- 큐에서 꺼낸 순서 = 시작점으로부터의 거리 순서

#### BFS vs DFS 선택 기준
```
BFS: 최단 경로, 최소 이동 횟수 → 이 문제에 적합 ✅
DFS: 모든 경로 탐색, 백트래킹 → 이 문제에는 비효율적 ❌
```

### 비트마스킹으로 확장하기

만약 레버가 여러 개(A, B, C)라면?
```python
# 레버 상태를 비트로 표현
# A(001), B(010), C(100)
lever_state = 0b000  # 아무것도 안 당김
lever_state |= (1 << 0)  # A 당김 → 0b001
lever_state |= (1 << 1)  # B 당김 → 0b011
lever_state |= (1 << 2)  # C 당김 → 0b111

# 상태: (x, y, lever_state)
visited = set()
visited.add((x, y, 0b101))  # A와 C를 당긴 상태
```

이 방식으로 최대 10개 정도의 레버 상태를 효율적으로 관리할 수 있습니다.

### 다익스트라로 확장하기

만약 각 칸마다 이동 비용이 다르다면?
```python
import heapq

# (비용, x, y, lever) 형태로 우선순위 큐 사용
pq = []
heapq.heappush(pq, (0, start_x, start_y, 0))

while pq:
    cost, x, y, lever = heapq.heappop(pq)

    # 최소 비용으로 도착한 경우만 처리
    if visited[x][y][lever]:
        continue
    visited[x][y][lever] = True

    # ...
```

### 핵심 개념 정리

1. **상태를 어떻게 정의할 것인가?** - 문제 해결의 첫걸음
2. **BFS는 가중치가 같을 때 최단 경로를 보장** - 이동 비용이 1일 때 최적
3. **3차원 이상의 상태 공간도 2차원처럼 탐색 가능** - visited를 tuple이나 set으로 관리
4. **비트마스킹은 여러 조건을 효율적으로 관리하는 도구** - 상태 수가 많아질 때 유용
