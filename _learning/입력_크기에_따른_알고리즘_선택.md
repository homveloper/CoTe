# 입력 크기에 따른 알고리즘 선택

> 코딩 테스트에서 제약 조건을 보고 적절한 알고리즘을 선택하는 방법을 정리한 학습 자료입니다.

## 핵심 원칙

### 왜 입력 크기가 중요한가?

코딩 테스트의 시간 제한은 보통 **1~2초**입니다. 이 시간 내에 프로그램이 실행되어야 하며, 일반적으로 **1초당 약 10^8(1억) 번의 연산**을 수행할 수 있다고 가정합니다.

따라서 **입력 크기 N을 보면 사용 가능한 알고리즘의 시간 복잡도 상한**을 알 수 있습니다.

### 알고리즘 선택 공식

```
허용 연산 횟수 = 시간 제한(초) × 10^8

목표: 시간 복잡도 × 입력 크기 ≤ 허용 연산 횟수
```

## 입력 크기별 알고리즘 선택 가이드

### 핵심 테이블 (반드시 암기)

| N의 크기 | 허용 복잡도 | 사용 가능한 알고리즘 |
|----------|-------------|---------------------|
| N ≤ **10** | O(N!) | 완전 탐색, 순열 |
| N ≤ **20~25** | O(2^N) | 비트마스크, 백트래킹 |
| N ≤ **50** | O(N^4) | 4중 루프 |
| N ≤ **200~500** | O(N^3) | 플로이드-워셜, 3중 루프 |
| N ≤ **3,000~5,000** | O(N^2) | 2중 루프, 단순 DP |
| N ≤ **100,000** | O(N log N) | 정렬, 이진 탐색, 세그먼트 트리 |
| N ≤ **1,000,000** | O(N) | 해시, 투 포인터, 슬라이딩 윈도우 |
| N ≤ **10,000,000** | O(N) | 선형 탐색 (상수 최적화 필요) |
| N > **10,000,000** | O(log N), O(1) | 수학, 이진 탐색 |

### 연산 횟수 계산 예시

**예시 1**: N = 1,000일 때

| 복잡도 | 연산 횟수 | 1초 내 가능? |
|--------|-----------|-------------|
| O(N) | 1,000 | ✅ 여유 |
| O(N log N) | 10,000 | ✅ 여유 |
| O(N²) | 1,000,000 | ✅ 가능 |
| O(N³) | 1,000,000,000 | ❌ 시간 초과 |

**예시 2**: N = 100,000일 때

| 복잡도 | 연산 횟수 | 1초 내 가능? |
|--------|-----------|-------------|
| O(N) | 100,000 | ✅ 여유 |
| O(N log N) | 1,700,000 | ✅ 여유 |
| O(N²) | 10,000,000,000 | ❌ 시간 초과 |

## 제약 조건 해석 방법

### Step 1: 제약 조건에서 N 찾기

문제에서 가장 큰 입력 크기를 찾습니다:

```
제약 조건:
- 1 ≤ N ≤ 100,000      ← N = 100,000
- 1 ≤ M ≤ 200,000      ← M = 200,000
- 1 ≤ K ≤ 1,000        ← K = 1,000
```

### Step 2: 허용 복잡도 판단

N = 100,000이면:
- O(N²) = 10^10 → ❌ 시간 초과
- O(N log N) = 1.7 × 10^6 → ✅ 가능
- **결론: O(N log N) 이하 알고리즘 필요**

### Step 3: 알고리즘 후보 나열

O(N log N) 이하 알고리즘들:
- 정렬 후 이진 탐색
- 힙 (우선순위 큐)
- 세그먼트 트리
- 투 포인터
- 슬라이딩 윈도우
- 해시

### Step 4: 문제 유형에 맞는 알고리즘 선택

## 복잡도별 대표 알고리즘

### O(1) - 상수 시간

```python
# 수학 공식 활용
def sum_1_to_n(n):
    return n * (n + 1) // 2

# 해시 테이블 조회
def hash_lookup(d, key):
    return d.get(key, -1)
```

**사용 시점**: 수학 공식으로 바로 계산 가능한 경우

### O(log N) - 로그 시간

```python
# 이진 탐색
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**사용 시점**: 정렬된 데이터에서 탐색, 결정 문제를 이진 탐색으로 변환

### O(N) - 선형 시간

```python
# 투 포인터
def two_sum_sorted(arr, target):
    left, right = 0, len(arr) - 1
    while left < right:
        current = arr[left] + arr[right]
        if current == target:
            return [left, right]
        elif current < target:
            left += 1
        else:
            right -= 1
    return []

# 슬라이딩 윈도우
def max_sum_subarray(arr, k):
    window_sum = sum(arr[:k])
    max_sum = window_sum
    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, window_sum)
    return max_sum
```

**사용 시점**: 배열 한 번 순회로 해결, 연속된 구간 문제

### O(N log N) - 선형 로그 시간

```python
# 정렬 + 이진 탐색
def count_pairs(arr, target):
    arr.sort()  # O(N log N)
    count = 0
    for i in range(len(arr)):
        # 이진 탐색으로 target - arr[i] 찾기
        idx = binary_search(arr, target - arr[i])
        if idx != -1 and idx != i:
            count += 1
    return count // 2
```

**사용 시점**: 정렬이 필요한 경우, 우선순위 기반 처리

### O(N²) - 제곱 시간

```python
# 2중 루프
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# 2차원 DP
def longest_common_subsequence(s1, s2):
    n, m = len(s1), len(s2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[n][m]
```

**사용 시점**: N ≤ 5,000 이하일 때, 2차원 DP

### O(N³) - 세제곱 시간

```python
# 플로이드-워셜
def floyd_warshall(n, edges):
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]

    for i in range(n):
        dist[i][i] = 0
    for u, v, w in edges:
        dist[u][v] = w

    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist
```

**사용 시점**: N ≤ 500, 모든 쌍 최단 경로

### O(2^N) - 지수 시간

```python
# 부분집합 탐색 (비트마스크)
def subset_sum(arr, target):
    n = len(arr)
    for mask in range(1 << n):  # 2^n
        total = 0
        for i in range(n):
            if mask & (1 << i):
                total += arr[i]
        if total == target:
            return True
    return False
```

**사용 시점**: N ≤ 20~25, 모든 부분집합 탐색

### O(N!) - 팩토리얼 시간

```python
# 순열 탐색
from itertools import permutations

def traveling_salesman_brute(n, dist):
    cities = list(range(n))
    min_cost = float('inf')

    for perm in permutations(cities):  # N!
        cost = sum(dist[perm[i]][perm[i+1]] for i in range(n-1))
        cost += dist[perm[-1]][perm[0]]  # 돌아오기
        min_cost = min(min_cost, cost)

    return min_cost
```

**사용 시점**: N ≤ 10, 모든 순열 탐색

## 실전 문제 분석 예시

### 예시 1: N = 1,000,000

**제약 조건**:
```
1 ≤ N ≤ 1,000,000
1 ≤ arr[i] ≤ 10^9
```

**분석**:
- O(N²) = 10^12 → ❌
- O(N log N) = 2 × 10^7 → ✅
- O(N) = 10^6 → ✅

**후보 알고리즘**:
- 해시맵 O(N)
- 정렬 + 이진 탐색 O(N log N)
- 투 포인터 O(N)
- 슬라이딩 윈도우 O(N)

### 예시 2: N = 20

**제약 조건**:
```
1 ≤ N ≤ 20
```

**분석**:
- O(2^N) = 1,048,576 → ✅
- O(N!) = 2.4 × 10^18 → ❌

**후보 알고리즘**:
- 비트마스크 DP
- 백트래킹
- Meet in the middle (절반 나누기)

### 예시 3: 그래프 문제

**제약 조건**:
```
노드 수: 1 ≤ V ≤ 500
간선 수: 1 ≤ E ≤ 10,000
```

**최단 경로 알고리즘 선택**:
- V = 500 → 플로이드-워셜 O(V³) = 1.25 × 10^8 → ⚠️ 경계
- 다익스트라 O(E log V) = 1.3 × 10^5 → ✅ 안전

**결론**: 다익스트라 사용 권장

## 특수한 경우 처리

### 여러 변수가 있는 경우

**제약 조건**:
```
1 ≤ N ≤ 100,000
1 ≤ M ≤ 100,000
1 ≤ K ≤ 100
```

**분석**:
- O(N × M) = 10^10 → ❌
- O(N × K) = 10^7 → ✅
- O((N + M) × K) = 2 × 10^7 → ✅

**전략**: 작은 변수(K)를 활용한 루프 설계

### 문자열 문제

**제약 조건**:
```
문자열 길이: 1 ≤ |S| ≤ 100,000
```

**알고리즘 선택**:
- 단순 매칭 O(N × M) → ❌
- KMP O(N + M) → ✅
- 해시 (라빈-카프) O(N + M) → ✅

### 숫자 범위가 큰 경우

**제약 조건**:
```
1 ≤ N ≤ 10^9
```

**주의**: N이 10^9이면 배열 자체를 만들 수 없음!

**해결 방법**:
- 좌표 압축
- 이진 탐색 (parametric search)
- 수학적 공식
- 희소 배열 (sparse array)

## 흔한 실수와 해결법

### 실수 1: 복잡도만 보고 상수 무시

**문제**: O(N)이라도 상수가 크면 시간 초과

```python
# 느림: 매번 리스트 생성
for i in range(n):
    temp = [x for x in arr if x > i]  # O(N) × N = O(N²)

# 빠름: 한 번만 순회
result = []
for x in arr:
    result.append(x)
```

### 실수 2: 재귀 호출 횟수 간과

```python
# 피보나치 - 지수 시간 O(2^N)
def fib_slow(n):
    if n <= 1:
        return n
    return fib_slow(n-1) + fib_slow(n-2)

# 메모이제이션 - 선형 시간 O(N)
from functools import lru_cache

@lru_cache(maxsize=None)
def fib_fast(n):
    if n <= 1:
        return n
    return fib_fast(n-1) + fib_fast(n-2)
```

### 실수 3: 공간 복잡도 간과

**제약 조건**: N = 10^7

```python
# 메모리 초과 가능
dp = [[0] * n for _ in range(n)]  # O(N²) 공간

# 공간 최적화
prev = [0] * n
curr = [0] * n  # O(N) 공간
```

### 실수 4: Python 특성 무시

Python은 다른 언어보다 **5~10배 느림**

```python
# 느림
result = 0
for i in range(n):
    result += arr[i]

# 빠름
result = sum(arr)  # C로 구현된 내장 함수
```

**Python 시간 제한 팁**:
- 10^7 연산이 한계라고 생각
- 내장 함수 적극 활용 (sum, max, min, sorted)
- PyPy 사용 가능하면 사용

## 문제 유형별 알고리즘 매핑

### 탐색/최적화 문제

| 상황 | N 범위 | 알고리즘 |
|------|--------|----------|
| 모든 경우 탐색 | N ≤ 10 | 완전 탐색, 순열 |
| 부분집합 | N ≤ 20 | 비트마스크, 백트래킹 |
| 최적값 찾기 | N ≤ 10^5 | 이진 탐색, DP |
| 구간 최적화 | N ≤ 10^5 | 투 포인터, 슬라이딩 윈도우 |

### 그래프 문제

| 상황 | 크기 | 알고리즘 |
|------|------|----------|
| 모든 쌍 최단거리 | V ≤ 500 | 플로이드-워셜 O(V³) |
| 단일 출발 최단거리 | V ≤ 10^5 | 다익스트라 O(E log V) |
| 음수 가중치 | V ≤ 10^3 | 벨만-포드 O(VE) |
| 연결 요소 | V ≤ 10^5 | DFS/BFS O(V+E) |

### DP 문제

| 상태 공간 | 크기 제한 | 복잡도 |
|-----------|-----------|--------|
| 1차원 | N ≤ 10^6 | O(N) |
| 2차원 | N × M ≤ 10^6 | O(NM) |
| 비트마스크 | N ≤ 20 | O(2^N × N) |
| 구간 DP | N ≤ 500 | O(N³) |

## 체크리스트: 알고리즘 선택 순서

문제를 읽고 다음 순서로 판단:

### 1. 제약 조건 확인
- [ ] N의 최댓값 확인
- [ ] 시간 제한 확인 (보통 1~2초)
- [ ] 메모리 제한 확인

### 2. 허용 복잡도 계산
- [ ] N으로부터 허용 복잡도 역산
- [ ] 여러 변수 있으면 곱셈 관계 파악

### 3. 문제 유형 파악
- [ ] 탐색? 최적화? 계산?
- [ ] 그래프? 문자열? 수학?

### 4. 알고리즘 후보 나열
- [ ] 복잡도 맞는 알고리즘 목록 작성
- [ ] 문제 유형에 맞는 것 선택

### 5. 구현 전 검증
- [ ] 최악의 경우 연산 횟수 계산
- [ ] 공간 복잡도도 확인

## 복잡도별 연습 문제 (쉬운 문제 위주)

> 제약 조건을 보고 알고리즘을 선택하는 연습용 문제들입니다.
> 각 문제를 풀기 전에 **제약 조건 → 허용 복잡도 → 알고리즘** 순서로 생각해보세요.

### O(N) - 선형 시간 연습

| 문제 | 플랫폼 | 제약 조건 | 핵심 알고리즘 | 난이도 |
|------|--------|-----------|---------------|--------|
| [두 개 뽑아서 더하기](https://school.programmers.co.kr/learn/courses/30/lessons/68644) | 프로그래머스 | N ≤ 100 | 완전 탐색 (N² 가능) | ⭐ |
| [완주하지 못한 선수](https://school.programmers.co.kr/learn/courses/30/lessons/42576) | 프로그래머스 | N ≤ 100,000 | 해시맵 O(N) | ⭐ |
| [폰켓몬](https://school.programmers.co.kr/learn/courses/30/lessons/1845) | 프로그래머스 | N ≤ 10,000 | 해시셋 O(N) | ⭐ |
| [10828 - 스택](https://www.acmicpc.net/problem/10828) | 백준 | N ≤ 10,000 | 스택 O(N) | 브론즈 |
| [1546 - 평균](https://www.acmicpc.net/problem/1546) | 백준 | N ≤ 1,000 | 단순 순회 O(N) | 브론즈 |

**연습 포인트**: N ≤ 100,000이면 O(N) 또는 O(N log N) 필요

---

### O(N log N) - 정렬/이진탐색 연습

| 문제 | 플랫폼 | 제약 조건 | 핵심 알고리즘 | 난이도 |
|------|--------|-----------|---------------|--------|
| [K번째수](https://school.programmers.co.kr/learn/courses/30/lessons/42748) | 프로그래머스 | N ≤ 100 | 정렬 O(N log N) | ⭐ |
| [가장 큰 수](https://school.programmers.co.kr/learn/courses/30/lessons/42746) | 프로그래머스 | N ≤ 100,000 | 정렬 O(N log N) | ⭐⭐ |
| [1920 - 수 찾기](https://www.acmicpc.net/problem/1920) | 백준 | N ≤ 100,000 | 이진 탐색 O(log N) | 실버 |
| [10816 - 숫자 카드 2](https://www.acmicpc.net/problem/10816) | 백준 | N ≤ 500,000 | 이진 탐색/해시 | 실버 |
| [2751 - 수 정렬하기 2](https://www.acmicpc.net/problem/2751) | 백준 | N ≤ 1,000,000 | O(N log N) 정렬 필수 | 실버 |

**연습 포인트**: N ≥ 10,000이면 O(N²) 정렬(버블/선택) 불가, O(N log N) 필요

---

### O(N²) - 2중 루프 연습

| 문제 | 플랫폼 | 제약 조건 | 핵심 알고리즘 | 난이도 |
|------|--------|-----------|---------------|--------|
| [행렬의 곱셈](https://school.programmers.co.kr/learn/courses/30/lessons/12949) | 프로그래머스 | N, M ≤ 100 | 3중 루프 O(N³) | ⭐⭐ |
| [2798 - 블랙잭](https://www.acmicpc.net/problem/2798) | 백준 | N ≤ 100 | 3중 루프 O(N³) | 브론즈 |
| [2231 - 분해합](https://www.acmicpc.net/problem/2231) | 백준 | N ≤ 1,000,000 | 완전 탐색 O(N) | 브론즈 |
| [1018 - 체스판 다시 칠하기](https://www.acmicpc.net/problem/1018) | 백준 | N, M ≤ 50 | 완전 탐색 O(NM) | 실버 |
| [1436 - 영화감독 숌](https://www.acmicpc.net/problem/1436) | 백준 | N ≤ 10,000 | 완전 탐색 | 실버 |

**연습 포인트**: N ≤ 1,000이면 O(N²) 가능, N ≤ 500이면 O(N³) 가능

---

### O(2^N) - 비트마스크/백트래킹 연습

| 문제 | 플랫폼 | 제약 조건 | 핵심 알고리즘 | 난이도 |
|------|--------|-----------|---------------|--------|
| [모의고사](https://school.programmers.co.kr/learn/courses/30/lessons/42840) | 프로그래머스 | N ≤ 10,000 | 완전 탐색 O(N) | ⭐ |
| [소수 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/42839) | 프로그래머스 | N ≤ 7 | 순열 O(N!) | ⭐⭐ |
| [카펫](https://school.programmers.co.kr/learn/courses/30/lessons/42842) | 프로그래머스 | N ≤ 2,000,000 | 약수 탐색 O(√N) | ⭐⭐ |
| [15649 - N과 M (1)](https://www.acmicpc.net/problem/15649) | 백준 | N ≤ 8 | 백트래킹 | 실버 |
| [1182 - 부분수열의 합](https://www.acmicpc.net/problem/1182) | 백준 | N ≤ 20 | 비트마스크 O(2^N) | 실버 |

**연습 포인트**: N ≤ 20이면 O(2^N) 가능, N ≤ 10이면 O(N!) 가능

---

### BFS/DFS 연습

| 문제 | 플랫폼 | 제약 조건 | 핵심 알고리즘 | 난이도 |
|------|--------|-----------|---------------|--------|
| [타겟 넘버](https://school.programmers.co.kr/learn/courses/30/lessons/43165) | 프로그래머스 | N ≤ 20 | DFS O(2^N) | ⭐⭐ |
| [게임 맵 최단거리](https://school.programmers.co.kr/learn/courses/30/lessons/1844) | 프로그래머스 | N, M ≤ 100 | BFS O(NM) | ⭐⭐ |
| [네트워크](https://school.programmers.co.kr/learn/courses/30/lessons/43162) | 프로그래머스 | N ≤ 200 | DFS/BFS O(N²) | ⭐⭐⭐ |
| [1260 - DFS와 BFS](https://www.acmicpc.net/problem/1260) | 백준 | N ≤ 1,000 | DFS/BFS O(N+E) | 실버 |
| [2178 - 미로 탐색](https://www.acmicpc.net/problem/2178) | 백준 | N, M ≤ 100 | BFS O(NM) | 실버 |

**연습 포인트**: 그래프 탐색은 O(V+E), 2D 그리드는 O(NM)

---

### DP 연습

| 문제 | 플랫폼 | 제약 조건 | 핵심 알고리즘 | 난이도 |
|------|--------|-----------|---------------|--------|
| [N으로 표현](https://school.programmers.co.kr/learn/courses/30/lessons/42895) | 프로그래머스 | N 사용 ≤ 8 | DP O(8²) | ⭐⭐⭐ |
| [정수 삼각형](https://school.programmers.co.kr/learn/courses/30/lessons/43105) | 프로그래머스 | N ≤ 500 | DP O(N²) | ⭐⭐⭐ |
| [1003 - 피보나치 함수](https://www.acmicpc.net/problem/1003) | 백준 | N ≤ 40 | DP O(N) | 실버 |
| [1149 - RGB거리](https://www.acmicpc.net/problem/1149) | 백준 | N ≤ 1,000 | DP O(N) | 실버 |
| [11053 - 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053) | 백준 | N ≤ 1,000 | DP O(N²) | 실버 |

**연습 포인트**: 1차원 DP는 O(N) 또는 O(N²), 2차원은 O(NM)

---

### 이진 탐색 (Parametric Search) 연습

| 문제 | 플랫폼 | 제약 조건 | 핵심 알고리즘 | 난이도 |
|------|--------|-----------|---------------|--------|
| [입국심사](https://school.programmers.co.kr/learn/courses/30/lessons/43238) | 프로그래머스 | N ≤ 100,000 | 이진 탐색 O(N log M) | ⭐⭐⭐ |
| [2805 - 나무 자르기](https://www.acmicpc.net/problem/2805) | 백준 | N ≤ 1,000,000 | 이진 탐색 O(N log H) | 실버 |
| [1654 - 랜선 자르기](https://www.acmicpc.net/problem/1654) | 백준 | K ≤ 10,000 | 이진 탐색 O(K log L) | 실버 |
| [2110 - 공유기 설치](https://www.acmicpc.net/problem/2110) | 백준 | N ≤ 200,000 | 이진 탐색 O(N log D) | 골드 |

**연습 포인트**: "최솟값의 최댓값" 또는 "최댓값의 최솟값" → 이진 탐색

---

## 연습 방법

### 1단계: 제약 조건만 보고 알고리즘 추측

문제를 열기 전에 제약 조건만 보고 예상:

```
N ≤ 100,000 → "O(N log N) 이하겠구나"
N ≤ 20 → "완전 탐색이나 비트마스크겠구나"
N ≤ 500 → "O(N²) DP나 그래프겠구나"
```

### 2단계: 문제 읽고 검증

예상한 복잡도가 맞는지 확인하고, 구체적인 알고리즘 선택

### 3단계: 오답 시 분석

시간 초과가 나면:
- 내 풀이의 복잡도 계산
- 제약 조건에서 허용하는 복잡도와 비교
- 더 효율적인 알고리즘으로 수정

### 추천 순서

1. **O(N) 문제** 5개 → 해시, 투 포인터 감각
2. **O(N log N) 문제** 5개 → 정렬, 이진 탐색 감각
3. **O(N²) 문제** 5개 → 완전 탐색, 2중 루프 감각
4. **BFS/DFS 문제** 5개 → 그래프 복잡도 감각
5. **O(2^N) 문제** 3개 → 지수 시간 한계 감각

총 **23문제**를 풀면 제약 조건 → 알고리즘 매핑이 자연스러워집니다.

---

## 관련 문제 추천 (심화)

### 프로그래머스

1. **입국심사** (Level 3)
   - N이 크므로 이진 탐색 필요
   - 핵심: 결정 문제로 변환

2. **디스크 컨트롤러** (Level 3)
   - N ≤ 500이지만 정렬 + 힙 필요
   - 핵심: 우선순위 큐 활용

3. **단어 변환** (Level 3)
   - N ≤ 50이므로 BFS 가능
   - 핵심: 그래프 모델링

### 백준

1. **1920 - 수 찾기**
   - N ≤ 100,000
   - 이진 탐색 또는 해시셋

2. **2805 - 나무 자르기**
   - N ≤ 1,000,000
   - Parametric Search

3. **11723 - 집합**
   - M ≤ 3,000,000
   - 비트마스크 O(1) 연산

## 학습 팁

### 복잡도 감각 기르기

1. **손으로 계산 연습**: 10^6, 10^8 같은 숫자에 익숙해지기
2. **문제 많이 풀기**: 제약 조건 → 알고리즘 매핑 패턴화
3. **오답 분석**: 시간 초과 시 복잡도 재계산

### 암기할 것

- **10^8 = 1초 기준**
- **N ≤ 5,000 → O(N²) 가능**
- **N ≤ 100,000 → O(N log N) 이하**
- **N ≤ 20 → O(2^N) 가능**

### 실전 전략

1. 제약 조건 먼저 확인
2. 단순한 풀이부터 생각
3. 복잡도 계산으로 가능 여부 판단
4. 불가능하면 최적화 방법 고민

---

**작성일**: 2025-11-19

**핵심 메시지**: 제약 조건이 곧 힌트다! N을 보면 알고리즘이 보인다.
