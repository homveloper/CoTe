# 트리 트리오 중간값

- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/68937

```
#트리 #BFS #트리지름 #Level4
```

---

## 문제 설명

n개의 점으로 이루어진 트리에서 임의의 세 점 a, b, c를 선택합니다.
세 점 사이의 거리 dist(a,b), dist(b,c), dist(c,a) 중 중간값의 최댓값을 구합니다.

## 문제 입출력

- 입력: n (노드 수), edges (간선 정보)
- 출력: 중간값의 최댓값

예시:
- n=4, edges=[[1,2],[2,3],[3,4]] → 2

---

## 풀이 과정

### 0단계: 현재 접근 방식 분석 (왜 막혔는가?)

**solution.py 주석에서 보이는 사고:**
```python
# 정점 조합을 이용해서 3개 정점 리스트를 만듬
from itertools import combinations
# 각 조합에 대해 거리 계산 후 중간값 저장
```

**왜 이 접근이 안 되는가?**

| 항목 | 값 | 문제 |
|------|-----|------|
| N | 250,000 | 매우 큼 |
| C(N, 3) | ≈ 2.6 × 10^15 | **계산 불가능** |
| 캐싱해도 | O(N³) | 시간 초과 |

**정확한 분석:**
```
C(250000, 3) = 250000 × 249999 × 249998 / 6
            ≈ 2,604,145,833,312,500
            ≈ 2.6 × 10^15 (2600조)
```

1초에 10^8 연산 가정 시 → **26,000,000초 (약 300일)** 소요

---

### 1단계: 제약 조건 분석

```
n: 3 ≤ n ≤ 250,000
edges: n-1개 (트리 구조)
```

**허용 복잡도 분석:**

| 복잡도 | 연산 횟수 | 가능 여부 |
|--------|----------|----------|
| O(N³) | 1.5 × 10^16 | ❌ 불가능 |
| O(N²) | 6.25 × 10^10 | ❌ 불가능 |
| O(N log N) | 4.4 × 10^6 | ✅ 가능 |
| O(N) | 2.5 × 10^5 | ✅ 가능 |

**결론:** O(N) 또는 O(N log N) 알고리즘이 필요

---

### 2단계: 문제 재해석 - "중간값의 최댓값"이란?

세 거리를 정렬했을 때: `[min, mid, max]`

**중간값(mid)을 최대화하려면?**

- mid ≤ max 이므로, max가 최대한 커야 함
- mid ≥ min 이므로, min이 최대한 커야 함
- 결국 **세 거리가 모두 크고, 비슷해야** 중간값이 최대

**핵심 통찰:**
> 트리에서 가장 긴 거리 = **지름(diameter)**
>
> 지름을 만드는 두 점 u, v는 반드시 선택해야 함!

---

### 3단계: 트리 지름 활용 전략

**트리 지름이란?**
- 트리에서 가장 먼 두 점 사이의 거리
- 예: 일자 트리 1-2-3-4 → 지름 = 3 (1에서 4까지)

**지름을 구하는 방법 (2번의 BFS):**
1. 임의의 점에서 BFS → 가장 먼 점 u 찾기
2. u에서 BFS → 가장 먼 점 v 찾기
3. dist(u, v) = 지름

**왜 이게 맞는가?**
- 트리에서 어떤 점 x에서 가장 먼 점은 반드시 지름의 한쪽 끝점

---

### 4단계: 세 번째 점 w 선택 전략

지름의 양 끝점 u, v를 선택했으면, 세 번째 점 w는 어떻게?

**경우 1: 답이 지름인 경우**

세 거리가 모두 지름과 같으면 중간값 = 지름

언제 가능한가?
- dist(u, w) = 지름인 w가 v 외에 또 있거나
- dist(v, w) = 지름인 w가 u 외에 또 있으면

**경우 2: 답이 지름-1인 경우**

위 조건이 안 되면, 중간값은 최대 지름-1

**왜 지름-1인가?**
- u, v, w를 선택하면:
  - dist(u, v) = 지름 (최대)
  - dist(u, w) + dist(w, v) ≥ dist(u, v) (트리 성질)
  - 중간값 = min(dist(u,w), dist(v,w))의 최대 = 지름/2 정도...?

아니다! 더 정확히 분석해보자:

```
u ------- v  (지름 = D)
     |
     w

dist(u,v) = D
dist(u,w) = a
dist(v,w) = b

w가 u-v 경로 위에 있으면: a + b = D
w가 u-v 경로 밖에 있으면: a + b > D
```

**중간값 = 세 거리 중 두 번째로 큰 값**

정렬하면: `[min(a,b), max(a,b), D]` 또는 `[D, ...]` 중 하나

결국 중간값 = max(a, b) (단, max(a,b) < D일 때)

**max(a, b)를 최대화하려면?**
- w를 u 또는 v에서 가장 먼 점으로 선택!

---

### 5단계: 최종 알고리즘

```python
def solution(n, edges):
    # 1. 그래프 구성
    graph = [[] for _ in range(n + 1)]
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)

    # 2. BFS 함수: 시작점에서 모든 점까지의 거리
    def bfs(start):
        dist = [-1] * (n + 1)
        dist[start] = 0
        queue = deque([start])
        farthest = start
        max_dist = 0

        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if dist[neighbor] == -1:
                    dist[neighbor] = dist[node] + 1
                    queue.append(neighbor)
                    if dist[neighbor] > max_dist:
                        max_dist = dist[neighbor]
                        farthest = neighbor

        return dist, farthest, max_dist

    # 3. 지름 구하기 (2번의 BFS)
    _, u, _ = bfs(1)           # 임의의 점에서 가장 먼 점 u
    dist_u, v, diameter = bfs(u)  # u에서 가장 먼 점 v, 지름
    dist_v, _, _ = bfs(v)      # v에서 모든 점까지 거리

    # 4. 답 결정
    # u에서 지름 거리인 점이 여러 개인가?
    count_u = sum(1 for d in dist_u if d == diameter)
    # v에서 지름 거리인 점이 여러 개인가?
    count_v = sum(1 for d in dist_v if d == diameter)

    if count_u >= 2 or count_v >= 2:
        return diameter
    else:
        return diameter - 1
```

**복잡도:** O(N) - BFS 3번

---

### 6단계: 왜 이게 맞는지 증명

**답이 지름인 경우:**
- u에서 거리 = 지름인 점이 v, w 두 개 이상이면
- dist(u, v) = dist(u, w) = 지름
- dist(v, w) ≥ 지름 (삼각부등식의 변형)
- 실제로 dist(v, w) = 지름이 됨 (트리의 성질)
- 세 거리: [지름, 지름, 지름] → 중간값 = 지름

**답이 지름-1인 경우:**
- u에서 가장 먼 점이 v 하나뿐
- v에서 가장 먼 점이 u 하나뿐
- 세 번째 점 w를 어떻게 잡아도:
  - dist(u, w) < 지름 또는 dist(v, w) < 지름
  - 중간값 < 지름
- 최선의 선택: u에서 두 번째로 먼 점 (거리 = 지름-1)

---

### 핵심 아이디어 (최종 정리)

1. **조합 X, 트리 성질 활용 O**
2. **트리 지름이 핵심**: 가장 긴 거리 = 지름
3. **지름 끝점 2개는 반드시 선택**
4. **세 번째 점은 지름 거리를 만들 수 있는지로 판단**
5. **O(N) BFS 3번으로 해결**

### 접근 방법 (체계적 프로세스)

1. **제약 조건 확인** → N=25만, O(N²) 이상 불가
2. **문제 본질 파악** → 중간값 최대화 = 세 거리가 모두 크고 비슷해야
3. **트리 특수 성질 활용** → 지름이 최대 거리
4. **경우의 수 분석** → 지름 or 지름-1
5. **O(N) 알고리즘 설계** → BFS 3번

## 회고

### 배운 점

- 

### 어려웠던 부분

- 이번 문제는 트리지만 그래프와 BFS 그리고 거리를 측정하는 문제로 접근해야 하므로, 이전에 풀었던 문제들과는 다른 패턴이 보여 어려웠다.

### 개선할 점

- 

---

## 평가

### 현재 접근 방식의 문제점

**solution.py 코드 분석:**

```python
from itertools import combinations

# 정점 조합을 이용해서 3개 정점 리스트를 만듬
# ...
# 전체 중간값을 다 기록 후 최대값 확인
```

**심각한 문제:**

1. **시간복잡도 O(N³)**
   - C(250000, 3) ≈ 2.6 × 10^15
   - 약 300일 소요 (1초 = 10^8 연산 가정)

2. **캐싱으로도 해결 불가**
   - 거리 캐싱: O(N²) 메모리 → 62.5GB 필요
   - 여전히 O(N³) 시간

3. **완전탐색 사고에 갇힘**
   - "모든 조합을 확인해야 한다"는 직관
   - 트리의 특수한 성질을 활용하지 못함

### 왜 이런 실수를 했는가?

**문제 해결 순서의 오류:**

```
잘못된 순서:
1. 문제 읽기
2. "세 점 선택" → "조합!" (직관적 반응)
3. 구현 시도
4. N=25만 확인 → "막힘"
```

```
올바른 순서:
1. 문제 읽기
2. ⭐ 제약 조건 확인: N=25만 → O(N) 필요
3. ⭐ "조합은 불가능" 판단 (5초)
4. "그러면 어떤 성질을 이용해야 하지?" → 트리 지름
5. 알고리즘 설계
```

**핵심 실수:**
- **제약 조건을 먼저 보지 않음**
- 트리 문제에서 **트리만의 특수 성질**을 떠올리지 못함

### 개선할 점 (실전 사고 훈련법)

#### 1. "조합/순열" 보이면 즉시 복잡도 계산

```python
# 머릿속에서 자동으로:
combinations(n, 3)  # → O(N³)
combinations(n, 2)  # → O(N²)
permutations(n)     # → O(N!)

# N ≥ 10000이면? → 조합 접근 불가능!
```

**이 문제:** N=250000, 조합 3개 → **즉시 포기**

---

#### 2. 트리 문제 = 트리 특수 성질 활용

**트리의 특별한 성질들:**
- 순환 없음 → 두 점 사이 경로는 유일
- 지름 존재 → 가장 먼 두 점
- 지름 구하기 → BFS 2번으로 O(N)
- LCA (최소 공통 조상) → 거리 계산에 유용

**"트리에서 최대 거리" 문제가 나오면:**
→ **무조건 지름부터 생각!**

---

#### 3. 제약 조건 → 알고리즘 매핑 (복습)

| N 범위 | 가능 복잡도 | 알고리즘 힌트 |
|--------|------------|--------------|
| N ≤ 10 | O(N!) | 완전탐색, 순열 |
| N ≤ 20 | O(2^N) | 비트마스킹 |
| N ≤ 500 | O(N³) | 플로이드-워셜 |
| N ≤ 5000 | O(N²) | DP, 단순 BFS |
| **N ≤ 250000** | **O(N log N)** | **정렬, 이분탐색, BFS** |
| N ≤ 10^9 | O(log N) | 이분탐색, 수학 |

**이 문제:** N=250000 → O(N) 또는 O(N log N) → **BFS!**

---

#### 4. "중간값" 문제 접근법

**중간값을 최대화한다 = ?**

- 세 값 중 **가장 작은 값이 최대한 커야** 함
- 또는 **세 값이 비슷해야** 함

**트리에서 적용:**
- 세 거리가 모두 최대한 크고 비슷해야
- → 가장 큰 거리(지름)를 기준으로 생각
- → 지름 끝점 2개 + α

---

#### 5. 트리 지름 알고리즘 암기

```python
def get_diameter(n, graph):
    """트리 지름 구하기: O(N)"""

    def bfs(start):
        """시작점에서 가장 먼 점과 거리 반환"""
        dist = [-1] * (n + 1)
        dist[start] = 0
        queue = deque([start])
        farthest, max_dist = start, 0

        while queue:
            node = queue.popleft()
            for nei in graph[node]:
                if dist[nei] == -1:
                    dist[nei] = dist[node] + 1
                    queue.append(nei)
                    if dist[nei] > max_dist:
                        max_dist = dist[nei]
                        farthest = nei

        return farthest, max_dist, dist

    # 1. 임의의 점 → 가장 먼 점 u
    u, _, _ = bfs(1)
    # 2. u → 가장 먼 점 v (지름)
    v, diameter, dist_u = bfs(u)
    # 3. v에서의 거리도 필요하면
    _, _, dist_v = bfs(v)

    return diameter, u, v, dist_u, dist_v
```

**반드시 암기할 패턴!** 트리 지름 문제는 자주 나옴.

### 잘한 점

1. **캐싱 아이디어**
   - `sorted((a,b))`로 양방향 캐시 키 통일
   - 좋은 최적화 사고, 하지만 O(N³)에서는 의미 없음

2. **트리 구조 인식**
   - "트리는 순환이 없으므로 경로가 유일"
   - 올바른 통찰, 더 발전시켰으면 지름까지 갔을 것

3. **문제 분석 시도**
   - 주석으로 사고 과정 기록
   - N 제약 인식하고 "조합은 안 될 것 같다" 판단

### 다른 응용 방안

이 문제에서 사용한 **트리 지름 + BFS** 패턴:

1. **"트리에서 가장 먼 두 점"** → 지름 직접 활용
2. **"트리에서 모든 점 쌍 거리의 합"** → 각 간선이 몇 번 사용되는지 계산
3. **"트리 중심 찾기"** → 지름의 중간 지점
4. **"트리를 두 부분으로 나눌 때 최소 거리 차이"** → 지름 기준 분할

### 다른 추천 문제

1. **가장 먼 노드** (프로그래머스 Level 3)
   - BFS 기본, 한 점에서 가장 먼 노드들 찾기
   - 이 문제의 워밍업

2. **트리의 지름** (백준 1967)
   - 트리 지름 알고리즘 연습
   - 가중치 있는 트리 버전

3. **트리와 쿼리** (백준 15681)
   - 트리에서 서브트리 크기 구하기
   - DFS 활용

4. **LCA** (백준 11437, 11438)
   - 최소 공통 조상 알고리즘
   - 트리에서 두 점 사이 거리 빠르게 구하기

### 종합 평가

#### 현재 상태 진단

**좋은 점:**
- 문제를 분석하려는 시도 (주석 작성)
- N 제약 조건 인식 ("조합은 안 될 것 같다")
- 캐싱 최적화 아이디어

**문제점:**
- **제약 조건을 충분히 활용하지 못함**
- 트리의 특수 성질(지름)을 떠올리지 못함
- O(N³)이 불가능하다는 것을 알면서도 대안을 찾지 못함

---

#### 핵심 실수 분석

**"조합이 안 된다"까지는 올바른 판단이었지만, 그 다음 단계로 넘어가지 못함**

```
올바른 사고 흐름:
"조합 안 됨" → "O(N) 필요" → "트리 특수 성질?" → "지름!"

현재 사고 흐름:
"조합 안 됨" → "캐싱으로 최적화?" → "여전히 안 됨" → "막힘"
```

**필요한 전환:**
- "완전탐색을 최적화하자" ❌
- "완전히 다른 접근이 필요하다" ✅

---

#### 앞으로 어떻게 할 것인가? (액션 플랜)

**즉시 실천 (오늘):**

1. **트리 지름 알고리즘 암기**
   - BFS 2번으로 O(N)에 구하기
   - 종이에 3번 손으로 쓰기

2. **이 문제 직접 구현해보기**
   - 위의 알고리즘을 보고 solution.py 완성
   - 테스트 통과 후 회고 작성

**단기 목표 (1주일):**

- [ ] 가장 먼 노드 (프로그래머스) - BFS 기본
- [ ] 트리의 지름 (백준 1967) - 지름 알고리즘
- [ ] 트리와 쿼리 (백준 15681) - 서브트리 크기

**장기 목표 (1개월):**

- "트리 문제" 보면 자동으로:
  1. 지름
  2. LCA
  3. 서브트리 크기
  - 이 세 가지를 먼저 떠올리는 습관

---

#### 핵심 교훈 (반드시 기억)

> **"조합/순열 보이면 즉시 복잡도 계산"**
> **"N ≥ 10000이면 조합 접근 불가능"**
> **"트리 문제 = 트리 특수 성질 (지름, LCA) 활용"**

이 문제의 진짜 배움:
1. 제약 조건이 알고리즘을 결정한다 (N=25만 → O(N))
2. 완전탐색 최적화가 아니라 **완전히 다른 접근**이 필요할 때가 있다
3. 트리에는 **지름**이라는 강력한 성질이 있다

**지금 바로:**
1. 위의 알고리즘을 보고 solution.py 구현
2. `python3 test.py`로 테스트
3. 통과하면 회고에 **"내 언어로"** 정리

---
**복잡도**: O(N) - BFS 3번
**풀이 날짜**:
