from itertools import combinations

def solution(n, edges):
    # 캐싱을 이용하면 더 빠르게 할 수 있을듯?
    # 여기서는 양방향이므로 캐시는 정렬된 튜플로 해야겠다.  sorted((a,b))
    
    # 정점 조합을 이용해서 3개 정점 리스트를 만듬
    # 트리는 순환이 없으므로  구태여 배열 정점 정보로 트리를 재구성할 필요가 없지 않을까?
    # 어자피 갈 수 있는 길은 하나뿐일것 같음.
        
    # f(a,b,c) 함수 구현
    # 만약 이전에 계산한 결과가 있으면 그것을 사용
    # a와 b 거리 -> a에서 부터 b까지 거리 탐색
    # b와 c 거리 -> b에서 부터 c까지 거리 탐색
    # c와 a 거리 -> c에서 부터 a까지 거리 탐색
    # 해당 조합에 대한 중간값 저장
    # 전체 중간값을 다 기록 후 최대값 확인

    mids = []
    
    
    
    
    return max(mids)