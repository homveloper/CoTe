# 예상 대진표

- 링크: https://school.programmers.co.kr/learn/courses/30/lessons/12985
- 난이도: Level 2

```
#트리 #토너먼트 #시뮬레이션 #수학
```

## 풀이 과정

### 핵심 아이디어
-

### 접근 방법
1.
2.

## 회고

### 배운 점
-

### 어려웠던 부분
-

### 개선할 점
-

## 평가

### 개선할 점

#### 1. 비일관적인 부모 노드 계산 공식
현재 코드(`solution.py:32-33`):
```python
a = a//2          # a는 그냥 2로 나눔
b = (b-1)//2      # b는 1을 빼고 2로 나눔
```

이 방식은 **작동은 하지만 비일관적**이고 이해하기 어렵습니다.

**왜 `(x+1)//2`를 사용해야 하는가?**

**핵심 개념: 각 라운드별 자리 번호**

토너먼트는 대진표가 미리 정해져 있어, **누가 이기든 상관없이** 다음 라운드의 **자리 번호**가 고정됩니다:

```
8명 토너먼트 구조:

1라운드 (자리 1~8번):
  매치1: 1번 vs 2번  →  승자는 2라운드 "1번 자리"로
  매치2: 3번 vs 4번  →  승자는 2라운드 "2번 자리"로
  매치3: 5번 vs 6번  →  승자는 2라운드 "3번 자리"로
  매치4: 7번 vs 8번  →  승자는 2라운드 "4번 자리"로

2라운드 (자리 1~4번):
  매치1: 자리1 vs 자리2  →  승자는 3라운드 "1번 자리"로
  매치2: 자리3 vs 자리4  →  승자는 3라운드 "2번 자리"로
```

**패턴 발견: 인접한 홀수-짝수 쌍 = 같은 매치 = 같은 다음 라운드 자리**

| 현재 참가자 | 속한 매치 | 다음 라운드 자리 번호 | 공식 `(N+1)//2` |
|-----------|---------|------------------|---------------|
| 1, 2 | 매치 1 | → **1번 자리** | (1+1)//2 = (2+1)//2 = **1** |
| 3, 4 | 매치 2 | → **2번 자리** | (3+1)//2 = (4+1)//2 = **2** |
| 5, 6 | 매치 3 | → **3번 자리** | (5+1)//2 = (6+1)//2 = **3** |
| 7, 8 | 매치 4 | → **4번 자리** | (7+1)//2 = (8+1)//2 = **4** |

**직관적 이해:**
- 1번, 2번은 **같은 매치(매치1)**에 속함 → 다음 라운드 **같은 자리(1번)**
- `(N+1)//2`는 "N번 참가자가 속한 매치 번호" = "다음 라운드 자리 번호"

**개선된 코드:**
```python
def solution(n, a, b):
    answer = 0
    while a != b:
        a = (a + 1) // 2
        b = (b + 1) // 2
        answer += 1
    return answer
```

이 방식이 **일관적**이고 **직관적**입니다.

#### 2. 디버깅 코드 제거
`solution.py:30, 36`의 `print(a, b)` 문은 제출 전에 제거해야 합니다.

#### 3. 더 최적화된 풀이 고려
현재 풀이는 **O(log N)** 시간복잡도로 충분히 효율적이지만, 비트 연산을 활용하면 더 우아한 풀이가 가능합니다:

```python
def solution(n, a, b):
    answer = 0
    while a != b:
        a, b = (a + 1) // 2, (b + 1) // 2
        answer += 1
    return answer
```

또는 **XOR 비트 연산**을 활용한 방법:
```python
def solution(n, a, b):
    # a와 b가 다른 비트 위치를 찾으면 그게 만나는 라운드
    return ((a - 1) ^ (b - 1)).bit_length()
```

이 방식은 **O(1)** 시간에 답을 구할 수 있습니다.

### 잘한 점

#### 1. 수학적 접근으로 시뮬레이션 최적화
토너먼트를 라운드별로 직접 시뮬레이션하지 않고, **부모 노드로 올라가는 수학적 접근**을 사용한 점이 훌륭합니다. 이는 O(N) → O(log N)으로 복잡도를 크게 개선합니다.

#### 2. 문제의 핵심 파악
주석(`solution.py:3-4`)에서 "두 대상 노드가 동일한 위치에서 만나는 레벨"이라는 핵심을 정확히 파악했습니다. 이는 **LCA(Lowest Common Ancestor)** 문제의 변형임을 이해한 것입니다.

#### 3. 종료 조건의 명확성
`while a != b`로 두 참가자가 같은 번호가 될 때까지 반복하는 로직이 **간결하고 명확**합니다.

### 다른 응용 방안

#### 1. 완전 이진 트리에서 LCA 찾기
이 문제는 **완전 이진 트리에서 두 노드의 최소 공통 조상(LCA)을 찾는 문제**와 동일합니다.
- 트리 구조에서 `(node+1)//2`는 부모 노드를 의미
- 두 노드가 같아질 때까지 부모로 올라가면 LCA를 찾을 수 있음

#### 2. 토너먼트 시드 배정 시스템
실제 스포츠 토너먼트에서:
- 강팀과 약팀이 최대한 늦게 만나도록 배치
- 특정 두 팀이 몇 라운드에 만날지 예측
- 토너먼트 브래킷 생성 알고리즘

#### 3. 대진표 시각화
```
1라운드:  1vs2   3vs4   5vs6   7vs8
           ↓      ↓      ↓      ↓
2라운드:    1      2      3      4
             ↓            ↓
3라운드:          1            2
                    ↓
결승:                    1
```

각 참가자가 어느 라운드에서 만날지 시각화하는 프로그램 구현

### 다른 추천 문제

#### 1. 프로그래머스 - 이진 변환 반복하기
- **유사점**: 숫자를 반복적으로 변환하며 조건 만족 시까지 반복
- **링크**: https://school.programmers.co.kr/learn/courses/30/lessons/70129
- **난이도**: Level 2

#### 2. 백준 1991 - 트리 순회
- **유사점**: 완전 이진 트리 구조 이해
- **링크**: https://www.acmicpc.net/problem/1991
- **난이도**: Silver 1

#### 3. 백준 11437 - LCA (Lowest Common Ancestor)
- **유사점**: 트리에서 두 노드의 최소 공통 조상 찾기
- **링크**: https://www.acmicpc.net/problem/11437
- **난이도**: Gold 3

#### 4. LeetCode 236 - Lowest Common Ancestor of a Binary Tree
- **유사점**: 이진 트리에서 LCA 찾기 (일반 트리 버전)
- **링크**: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
- **난이도**: Medium

### 종합 평가

이 문제는 **토너먼트 구조를 완전 이진 트리로 모델링**하여 수학적으로 접근하는 능력을 테스트합니다.

**핵심 인사이트:**
1. **토너먼트 = 완전 이진 트리**: 1번부터 시작하는 토너먼트는 1-indexed 완전 이진 트리와 동일한 구조
2. **부모 노드 공식**: `(N+1)//2`는 토너먼트에서 다음 라운드 번호를 계산하는 공식
3. **LCA 개념**: 두 노드가 처음 만나는 지점 = 최소 공통 조상

**현재 풀이의 문제:**
- 비일관적인 공식 사용 (`a//2` vs `(b-1)//2`)이 혼란을 야기
- 작동은 하지만 **"왜 이렇게 되는가?"**를 설명하기 어려운 구조
- 디버깅 코드가 남아있음

**개선 방향:**
1. **일관성**: 모든 참가자에 대해 `(N+1)//2` 공식 사용
2. **가독성**: 변수명과 주석으로 의도 명확히 표현
3. **최적화**: 비트 연산을 활용한 O(1) 풀이 고려

**학습 포인트:**
- 완전 이진 트리의 인덱싱 (0-indexed vs 1-indexed)
- 부모-자식 관계 공식:
  - 0-indexed: 부모 = `(N-1)//2`, 자식 = `2N+1`, `2N+2`
  - 1-indexed: 부모 = `N//2`, 자식 = `2N`, `2N+1`
  - **토너먼트(1부터 시작)**: 부모 = `(N+1)//2`
- LCA(최소 공통 조상) 알고리즘의 기초

**최적화 사고 흐름:**
> "먼저 작동하는 코드를 작성하고, 패턴을 발견하면 수식으로 만든다"

이것이 **반복(순서)에서 수식으로의 전환** - 알고리즘 최적화의 본질입니다:
1. **반복문 풀이** (O(log N)): 먼저 직관적이고 작동하는 코드 작성
2. **패턴 발견**: 반복되는 연산에서 규칙성 찾기
3. **수학적 공식화**: 반복을 한 번에 계산하는 수식 도출
4. **비트 연산 최적화** (O(1)): 이진수 관점으로 재해석

이 문제를 통해 **시뮬레이션을 수학적 공식으로 대체하는 최적화 기법**을 배울 수 있었습니다. 하지만 공식의 일관성과 명확성을 더욱 높여야 코드의 품질이 향상될 것입니다.

## 추가 학습: 완전 이진 트리 인덱싱과 LCA

### 1. 완전 이진 트리의 인덱싱 체계

#### 0-indexed (배열 기준)
```
         0
       /   \
      1     2
     / \   / \
    3   4 5   6
```

- 부모 노드: `parent = (node - 1) // 2`
- 왼쪽 자식: `left = 2 * node + 1`
- 오른쪽 자식: `right = 2 * node + 2`

#### 1-indexed (일반 트리 이론)
```
         1
       /   \
      2     3
     / \   / \
    4   5 6   7
```

- 부모 노드: `parent = node // 2`
- 왼쪽 자식: `left = 2 * node`
- 오른쪽 자식: `right = 2 * node + 1`

#### 토너먼트 (1부터 시작, 인접 쌍 매칭)
```
1라운드:  1  2  3  4  5  6  7  8  ← 현재 자리 번호
           ↓   ↓   ↓   ↓
2라운드:    1     2     3     4   ← 다음 라운드 자리 번호
             ↓         ↓
3라운드:          1         2
                     ↓
4라운드:                1
```

- **다음 라운드 자리 번호**: `next = (current + 1) // 2`
- 이 공식이 필요한 이유:
  - 1번 자리 → (1+1)//2 = **1번 자리** (다음 라운드)
  - 2번 자리 → (2+1)//2 = **1번 자리** (같은 매치!)
  - 3번 자리 → (3+1)//2 = **2번 자리** (다음 라운드)
  - 4번 자리 → (4+1)//2 = **2번 자리** (같은 매치!)

### 2. LCA (Lowest Common Ancestor) 알고리즘

이 문제는 **완전 이진 트리에서 LCA를 찾는 문제**의 특수한 경우입니다.

#### 일반적인 LCA 알고리즘
1. **부모로 올라가며 비교**: 두 노드를 동시에 부모로 올리며 처음 만나는 지점 찾기
2. **깊이 맞추기**: 깊이가 다르면 먼저 같은 깊이로 맞춘 후 동시에 올라가기
3. **Binary Lifting**: 2^k 단계씩 점프하여 O(log N)에 찾기

이 문제는 **완전 이진 트리**이므로 깊이를 고려할 필요 없이 단순히 부모로 올라가기만 하면 됩니다.

### 3. 비트 연산을 활용한 최적화 (O(1) 풀이)

> **핵심 인사이트**: 이것은 **문제를 푼 이후 최적화가 필요할 때** 고민하는 방향입니다.
> **"반복(순서)로부터 수식을 만드는 방법"** - 이것이 알고리즘 최적화의 본질입니다.

#### 문제 해결의 진화 과정

```
1단계: 작동하는 코드 (반복문)
   ↓
   while a != b:
       a = (a+1)//2
       b = (b+1)//2

2단계: 패턴 발견
   ↓
   "매번 같은 연산을 반복하네? 규칙이 있을까?"
   → 이진수로 표현하면 비트 시프트와 비슷

3단계: 수학적 공식화
   ↓
   "반복을 한 번에 계산할 수 있을까?"
   → XOR + bit_length()로 한 번에 계산!

4단계: 최적화 완료
   ↓
   return ((a-1) ^ (b-1)).bit_length()

복잡도: O(log N) → O(1)
```

---

#### 최종 코드
```python
def solution(n, a, b):
    return ((a - 1) ^ (b - 1)).bit_length()
```

이 한 줄의 코드가 어떻게 작동하는지, **왜 이런 사고가 가능했는지** 단계별로 설명합니다.

---

#### 사고 과정 1: 문제를 다시 정의하기

**원래 질문**: a와 b가 몇 라운드 후에 만나는가?

**다르게 생각하기**:
- 매 라운드마다 `(N+1)//2`를 반복하면 결국 같아진다
- 이진수 관점에서 보면?

```
참가자 4번의 라운드별 위치:
1라운드: 4 (100₂)
2라운드: (4+1)//2 = 2 (010₂)  ← 거의 1비트 오른쪽 시프트
3라운드: (2+1)//2 = 1 (001₂)  ← 또 1비트 오른쪽 시프트
4라운드: (1+1)//2 = 1 (001₂)
```

**통찰**: `(N+1)//2`는 이진수에서 "오른쪽으로 비트 이동"과 비슷하다!

---

#### 사고 과정 2: 이진수로 패턴 찾기

예시: a=4, b=7이 언제 만나는가?

**시뮬레이션 (10진수)**:
```
라운드  |  a  |  b  |  같은가?
--------|-----|-----|--------
   1    |  4  |  7  |  X
   2    |  2  |  4  |  X
   3    |  1  |  2  |  X
   4    |  1  |  1  |  O  → 4라운드에서 만남
```

**이진수로 표현** (0-indexed: a-1=3, b-1=6):
```
라운드  |  a-1 (2진)  |  b-1 (2진)  |  같은가?
--------|------------|------------|--------
   0    |    011     |    110     |  X  ← 3번째 비트부터 다름
   1    |    001     |    011     |  X  ← 2번째 비트부터 다름
   2    |    000     |    001     |  X  ← 1번째 비트부터 다름
   3    |    000     |    000     |  O  → 모든 비트가 0
```

**핵심 발견**:
- 3과 6을 이진수로 비교: `011` vs `110`
- **최상위 다른 비트 위치**를 찾으면 그게 답!
- 011 XOR 110 = 101 (다른 비트만 1로 표시)
- 101의 비트 길이 = 3 → **3라운드!**

---

#### 사고 과정 3: XOR 연산의 의미

**XOR (^) 연산**: 두 비트가 다르면 1, 같으면 0

```
  a-1 = 3:  0 1 1
  b-1 = 6:  1 1 0
  ---------------  XOR
  결과 = 5:  1 0 1
            ↑
     최상위 비트(3번째 자리)
```

**XOR 결과의 의미**:
- `1`인 비트 = a와 b가 다른 비트 위치
- 최상위 `1` 비트 = 처음으로 다른 비트 위치
- 그 위치 = 몇 라운드 후에 만나는가!

---

#### 사고 과정 4: bit_length()의 역할

`bit_length()`는 **이진수의 비트 길이**를 반환합니다:

```python
bin(5)         # '0b101'
(5).bit_length()  # 3  ← '101'은 3비트 필요
```

예시:
```
5 (101₂) → bit_length() = 3
7 (111₂) → bit_length() = 3
8 (1000₂) → bit_length() = 4
```

**왜 bit_length()가 답인가?**
- XOR 결과의 최상위 비트 위치 = 라운드 수
- `bit_length()`가 바로 최상위 비트 위치를 반환!

---

#### 완전한 예시: a=4, b=7

**1단계: 0-indexed로 변환**
```python
a - 1 = 3  # 011₂
b - 1 = 6  # 110₂
```
왜 -1? → 토너먼트를 0부터 시작하는 배열로 생각하기 위해

**2단계: XOR로 다른 비트 찾기**
```python
3 ^ 6 = 5  # 011 XOR 110 = 101
```

**3단계: 최상위 비트 위치 구하기**
```python
(5).bit_length() = 3
```

**검증: 실제로 3라운드 맞나?**
```
1라운드: 4 → (4+1)//2 = 2,  7 → (7+1)//2 = 4  (다름)
2라운드: 2 → (2+1)//2 = 1,  4 → (4+1)//2 = 2  (다름)
3라운드: 1 → (1+1)//2 = 1,  2 → (2+1)//2 = 1  (같음!) ✓
```

---

#### 다른 예시: a=1, b=2

**단계별 계산**:
```python
a - 1 = 0  # 000₂
b - 1 = 1  # 001₂
0 ^ 1 = 1  # 001₂
(1).bit_length() = 1  → 1라운드에서 만남
```

**검증**:
```
1라운드: 1 → (1+1)//2 = 1,  2 → (2+1)//2 = 1  (같음!) ✓
```

---

#### 사고의 흐름 정리

```
1. 관찰: 매 라운드 (N+1)//2는 비트 시프트와 비슷
   ↓
2. 발견: 두 참가자의 비트 표현을 비교하면 패턴이 보임
   ↓
3. 통찰: XOR로 "다른 비트 위치" 찾기
   ↓
4. 핵심: 최상위 다른 비트 위치 = 만나는 라운드
   ↓
5. 구현: bit_length()로 최상위 비트 위치 구하기
```

---

#### 왜 이런 사고가 가능했는가?

1. **이진수 관점으로 문제 재해석**
   - 토너먼트를 단순 숫자가 아닌 "비트 패턴"으로 봄
   - `(N+1)//2`를 "비트 시프트"로 이해

2. **XOR의 특성 활용**
   - XOR은 "차이 찾기"에 최적화된 연산
   - 두 노드의 "경로 차이"를 한 번에 계산

3. **트리의 이진 구조**
   - 완전 이진 트리는 이진수와 완벽히 매핑
   - 비트 위치 = 트리의 깊이

4. **수학적 최적화 사고**
   - "반복 계산을 한 번에" → O(log N) → O(1)
   - 패턴을 공식으로 변환하는 능력

---

#### 비트 연산 vs 반복문 비교

| 특성 | 반복문 풀이 | 비트 연산 풀이 |
|-----|----------|------------|
| 시간복잡도 | O(log N) | **O(1)** |
| 공간복잡도 | O(1) | O(1) |
| 가독성 | ⭐⭐⭐⭐⭐ 직관적 | ⭐⭐ 이해 필요 |
| 실행 속도 | 빠름 | **더 빠름** |
| 코드 길이 | 5줄 | **1줄** |

**결론**:
- 코딩 테스트에서는 **반복문 풀이**가 더 안전하고 명확
- 비트 연산 풀이는 **최적화 인사이트**를 보여주는 데 유용
- 실무에서는 **가독성 > 미세한 성능 차이**

---
**복잡도**:
- 시간: O(log N) - while 루프가 최대 log₂(N)번 실행
- 공간: O(1) - 추가 자료구조 사용 안 함
- 최적화 시: O(1) - 비트 연산 활용

**풀이 날짜**: 2025-11-15
