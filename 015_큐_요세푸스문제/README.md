# 요세푸스 문제

#큐 #구현 #시뮬레이션

## 풀이 과정

### 핵심 아이디어
- `deque`의 회전 기능을 활용한 시뮬레이션
- K-1번 회전 후 맨 앞 요소 제거 반복
- 마지막 남은 사람 반환

### 접근 방법

1. **초기 설정**
   - 1부터 N까지의 사람을 deque에 저장
   - `deque([1, 2, 3, ..., N])`

2. **제거 과정 반복** (큐에 1명 남을 때까지)
   - K-1번 회전: 맨 앞을 맨 뒤로 이동
   - K번째 사람 제거: `popleft()`

3. **회전 원리**
   ```
   [1, 2, 3, 4, 5], K=2

   1회전 후: [2, 3, 4, 5]    (2번째 1 제거)
   → [3, 4, 5, 2]            (1번 회전)
   → [4, 5, 2]               (2번째 3 제거)
   → [5, 2, 4]               (1번 회전)
   → [2, 4]                  (2번째 5 제거)
   → [4, 2]                  (1번 회전)
   → [4]                     (2번째 2 제거)

   답: 4
   ```

4. **종료 조건**
   - 큐의 길이가 1이 되면 종료
   - `queue[0]` 반환

### 코드

```python
from collections import deque

def solution(N, K):
    queue = deque(range(1, N+1))

    while len(queue) > 1:
        # K-1번 회전: 앞에서 빼서 뒤로 추가
        for _ in range(K-1):
            queue.append(queue.popleft())

        # K번째 사람 제거
        queue.popleft()

    return queue[0]
```

### 시간 복잡도 분석

- **회전**: 각 제거 시 평균 K번 회전 → O(K)
- **제거**: N명 제거 → N-1번 반복
- **전체**: O(N × K)

**최적화 가능?**
- 수학 공식(Josephus 공식) 사용 시 O(N)
- 하지만 직관적인 시뮬레이션이 이해하기 쉬움

## 회고

### 배운 점
- 

### 어려웠던 부분
-

### 개선할 점
-

---
**복잡도**: 시간 O(N × K), 공간 O(N)
**풀이 날짜**: 2025-11-03
