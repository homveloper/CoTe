# 오픈채팅방
- 링크: https://school.programmers.co.kr/learn/courses/30/lessons/42888
- 출처: 2019 카카오 블라인드 채용
- 난이도: Level 2

```
#해시 #구현 #문자열
```

## 문제 설명

카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있다. 오픈채팅방에서는 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.

채팅방에서 나간 후, 새로운 닉네임으로 다시 들어갈 수도 있고, 채팅방 내에서 닉네임을 변경할 수도 있다.

**중요**: 닉네임 변경 시, 기존에 채팅방에 출력되어 있던 해당 유저의 모든 메시지 닉네임도 전부 변경된다.

## 풀이 과정

### 핵심 아이디어
- 유저 ID는 고유하며 변하지 않지만, 닉네임은 변경될 수 있다
- 모든 이벤트를 처리한 후 **최종 닉네임**으로 메시지를 출력해야 한다
- 2-pass 알고리즘: (1) 최종 닉네임 계산 → (2) 메시지 생성

### 접근 방법
1. 첫 번째 순회: 모든 `Enter`와 `Change` 이벤트를 처리하여 각 UID의 최종 닉네임을 해시맵에 저장
2. 두 번째 순회: `Enter`와 `Leave` 이벤트만 필터링하여 최종 닉네임으로 메시지 생성
3. `Change` 이벤트는 닉네임만 갱신하고 메시지는 출력하지 않음

### 코드

```python
def solution(record):
    message_formats = {
        'Enter': '{}님이 들어왔습니다.',
        'Leave': '{}님이 나갔습니다.'
    }

    # UID : 최종 닉네임 매핑
    nicknames = {}
    events = [tuple(raw_event.split(' ')) for raw_event in record]

    # 1단계: 최종 닉네임 계산
    for event in events:
        if event[0] == 'Enter':
            nicknames[event[1]] = event[2]
        elif event[0] == 'Change':
            nicknames[event[1]] = event[2]

    # 2단계: 메시지 생성
    result = []
    for event in events:
        cmd = event[0]
        nickname = nicknames.get(event[1], '')
        if cmd in message_formats:
            result.append(message_formats[cmd].format(nickname))

    return result
```

## 회고

### 배운 점
- 문제에 대한 설명을 충분히 확인하고, 이를 텍스트로 작성하면서 입출력이 어떻게 처리되는지 확인하니, 문제의 핵심 요구사항을 명확히 이해할 수 있었다.

### 어려웠던 부분
-

### 개선할 점
-

## 평가

### 개선할 점

**1. 불필요한 자료구조 변환 (solution.py:31)**
```python
events = [tuple(raw_event.split(' ')) for raw_event in record]
```
- `split()` 결과를 굳이 튜플로 변환할 필요가 없습니다. 리스트로도 인덱싱이 동일하게 작동하며, 튜플 변환은 추가적인 메모리와 시간을 소비합니다.
- 개선안: `events = [raw_event.split() for raw_event in record]`

**2. 중복 순회로 인한 메모리 낭비**
```python
for event in events:  # 첫 번째 순회
    if event[0] == 'Enter': ...

for event in events:  # 두 번째 순회
    cmd = event[0] ...
```
- 전체 record를 `events` 리스트로 변환한 후 2번 순회합니다.
- `Change` 이벤트는 메시지 생성에 사용되지 않는데도 `events`에 저장되어 메모리를 낭비합니다.
- 개선 방향: 첫 순회에서 `(command, user_id)` 쌍만 저장하여 메모리 효율성을 높일 수 있습니다.

**3. 방어적 코딩의 과도함 (solution.py:43)**
```python
nickname = nicknames.get(event[1], '')
```
- 문제 조건상 모든 UID는 `Enter`를 통해 등록되므로 기본값 `''`이 사용될 일이 없습니다.
- 불필요한 방어 코드는 오히려 잠재적 버그를 숨길 수 있습니다.
- 개선안: `nickname = nicknames[event[1]]`로 직접 접근하여 의도를 명확히 하고, KeyError 발생 시 문제를 즉시 파악할 수 있게 합니다.

**4. 변수명의 일관성 부족**
- `cmd`는 약어이고, `nickname`은 전체 단어입니다. 일관성 있게 `command`, `user_id` 등 명확한 이름을 사용하면 가독성이 향상됩니다.

### 잘한 점

**1. 정확한 알고리즘 선택**
- 2-pass 알고리즘(닉네임 갱신 → 메시지 생성)을 사용하여 문제의 핵심을 정확히 파악했습니다.
- "최종 닉네임을 먼저 계산한 후 이벤트를 처리"하는 접근법이 매우 명확합니다.

**2. 효율적인 시간 복잡도**
- O(N) 시간 복잡도로 문제를 해결하여 제약조건(최대 100,000건)을 충분히 만족합니다.
- 해시맵을 활용한 O(1) 조회로 최적의 성능을 보장합니다.

**3. 메시지 포맷 관리**
```python
message_formats = {
    'Enter': '{}님이 들어왔습니다.',
    'Leave': '{}님이 나갔습니다.'
}
```
- 메시지 템플릿을 딕셔너리로 분리하여 유지보수성과 확장성이 좋습니다.
- 새로운 이벤트 타입 추가 시 쉽게 대응할 수 있는 구조입니다.

**4. 명확한 사고 과정**
- 주석을 통해 문제 분석 과정을 잘 기록했습니다 (solution.py:3-21).
- 복잡도 제약 인식, 핵심 아이디어 도출, 구현 단계 설계가 체계적입니다.

### 다른 응용 방안

**1. 실시간 채팅 시스템**
- 현재 솔루션은 배치 처리 방식이지만, 실시간 채팅에서는 이벤트 스트림 처리가 필요합니다.
- Redis나 In-Memory DB를 사용한 UID-닉네임 캐싱 시스템으로 확장 가능합니다.

**2. 이벤트 소싱 패턴**
- `nicknames` 딕셔너리는 이벤트의 최종 상태를 나타냅니다.
- 이벤트 히스토리를 보존하면 "특정 시점의 닉네임" 조회 등 시간 여행(time-travel) 쿼리가 가능합니다.

**3. 다국어 메시지 시스템**
```python
message_formats = {
    'ko': {'Enter': '{}님이 들어왔습니다.', 'Leave': '{}님이 나갔습니다.'},
    'en': {'Enter': '{} has entered.', 'Leave': '{} has left.'}
}
```
- 현재 구조를 확장하여 다국어 지원 채팅 시스템으로 발전시킬 수 있습니다.

**4. 권한 관리 시스템**
- UID별 상태(닉네임)를 관리하는 패턴을 응용하여 사용자별 권한, 상태, 프로필 정보를 관리하는 시스템으로 확장 가능합니다.

### 종합 평가

알고리즘의 핵심을 정확히 파악하고 O(N) 시간 복잡도로 효율적으로 구현한 좋은 솔루션입니다. 특히 2-pass 접근법과 해시맵을 활용한 상태 관리가 인상적입니다.

그러나 코딩 테스트 관점에서 몇 가지 아쉬운 점이 있습니다. 첫째, 불필요한 자료구조 변환(튜플)과 중복 순회로 인한 메모리 낭비가 있습니다. 실제 대규모 입력에서는 이러한 작은 비효율이 누적되어 성능 차이를 만들 수 있습니다. 둘째, 방어적 코딩(`get()` 사용)이 오히려 잠재적 버그를 숨길 수 있습니다. 문제 조건을 정확히 이해했다면 직접 접근으로 의도를 명확히 하는 것이 더 좋습니다.

코드의 구조와 가독성은 우수하나, 실전에서는 **최소한의 메모리로 최대한의 효율**을 내는 것이 중요합니다. 예를 들어, `Change` 이벤트를 `events`에 저장하지 않거나, 첫 순회에서 `(command, user_id)` 쌍만 저장하는 등의 최적화를 고려해야 합니다.

정확성은 100점이지만, 효율성 측면에서 개선의 여지가 있습니다. 코딩 테스트에서는 "동작하는 코드"를 넘어 "최적화된 코드"를 작성하는 습관을 기르는 것이 중요합니다.

---
**복잡도**: O(N) / O(N)
**풀이 날짜**:
