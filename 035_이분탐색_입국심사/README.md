# 입국심사

- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/43238

```
#이분탐색 #파라메트릭서치 #Level3
```

---

## 문제 설명

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

## 문제 입출력

- 입력: n (입국심사를 기다리는 사람 수), times (각 심사관이 한 명을 심사하는데 걸리는 시간 배열)
- 출력: 모든 사람이 심사를 받는데 걸리는 최소 시간

예시:
- n=6, times=[7, 10] → 28

---

## 풀이 과정

### 0단계: 문제를 이해하기 전에 "왜 막혔는가?" 분석

**처음 든 생각 (solution.py 주석):**
```
fanout 느낌인데 최솟값이 필요함
→ 각 사람을 어느 심사대에 배정할지 결정하는 문제로 인식
→ 그리디? 시뮬레이션? 완전탐색?
```

**왜 이렇게 생각했을까?**
- "사람을 배정한다" → 직관적인 접근
- "최솟값" → 그리디로 매번 최선의 선택?
- 하지만 n이 너무 크다... 막힘

**이 시점에서 필요한 것: 문제 재구성**

---

### 1단계: 제약 조건부터 확인하라 (가장 중요!)

```
n: 1 ≤ n ≤ 1,000,000,000 (10억)
times 배열 길이: 1 ≤ length ≤ 100,000
각 심사 시간: 1 ≤ times[i] ≤ 1,000,000,000
```

**🚨 즉시 알아차려야 할 시그널:**

| 조건 | 의미 | 불가능한 접근 |
|------|------|---------------|
| n ≤ 10억 | 사람 수가 매우 크다 | O(N) 반복문 불가능 |
| times ≤ 10만 | 심사대는 적다 | 심사대 기준 연산은 OK |
| 시간 ≤ 10억 | 범위가 크다 | 완전탐색 불가능 |

**결론: "사람을 하나씩 처리"하는 시뮬레이션은 절대 불가능**

---

### 2단계: 접근 방법 후보 나열 → 제거 (소거법)

#### 후보 1: 완전탐색 (모든 경우의 수)
```
각 사람을 어느 심사대에 배정할지 → 100,000^1,000,000,000 경우의 수
```
❌ **즉시 제거**: 계산 불가능

#### 후보 2: 그리디 (매번 최선의 선택)
```python
# 가장 빨리 끝나는 심사대에 배정
for i in range(n):  # n번 반복
    가장_빨리_끝나는_심사대에_배정()
```
❌ **제거 이유**:
- n이 10억이면 10억 번 반복 → 시간 초과
- 그리디가 항상 최적해를 보장하는가? (증명 어려움)

#### 후보 3: DP (동적 계획법)
```
dp[i] = i명을 심사하는 최소 시간?
```
❌ **제거 이유**:
- 상태 공간이 10억 → 메모리 초과
- 점화식도 명확하지 않음

#### 후보 4: 이분탐색???
```
"최소 시간"을 찾는다...
시간 범위가 [1, 10^18]로 매우 크다...
어떤 조건을 만족하는 최솟값?
```
✅ **가능성 있음** → 더 탐구 필요

---

### 3단계: "발상의 전환" - 질문을 바꿔라

**원래 질문:**
> "모든 사람이 심사받는 최소 시간은?"

**이렇게 바꿔 물어보자:**
> "시간 T가 주어졌을 때, T 시간 안에 n명을 심사할 수 있는가?"

**왜 이게 중요한가?**

| 원래 질문 | 바꾼 질문 |
|-----------|-----------|
| 답을 **찾는** 문제 | 답을 **검증하는** 문제 |
| "얼마나 걸릴까?" | "가능한가?" (Yes/No) |
| 어렵다 | 쉽다! |

**검증 함수 (Decision Function) 만들기:**
```python
def can_finish(time, times, n):
    """time 시간 안에 n명을 심사할 수 있는가?"""
    total = 0
    for t in times:
        total += time // t  # 각 심사대에서 처리 가능한 인원
    return total >= n
```

**이제 깨달음:**
- `can_finish(100)`이 True인데 `can_finish(50)`이 False라면?
- → 50과 100 사이 어딘가에 **경계값(답)**이 있다!
- → 이분탐색으로 그 경계를 찾을 수 있다!

---

### 4단계: 이분탐색 패턴 인식

**이분탐색이 가능한 조건 (체크리스트):**

1. ✅ **범위가 크다**: 시간 범위 [1, 10^18]
2. ✅ **단조성(Monotonicity)**:
   - 시간 t에서 가능하면 → t+1에서도 가능
   - 시간 t에서 불가능하면 → t-1에서도 불가능
3. ✅ **검증 함수를 O(N)에 구현 가능**:
   - N = times 배열 길이 (최대 10만)
   - 각 심사대별로 처리 인원 계산: `time // times[i]`
4. ✅ **최소/최대를 찾는 문제**: "최소 시간"

**→ 4가지 모두 만족! 이분탐색 확정**

---

### 5단계: 구체적 예시로 검증 (손으로 시뮬레이션)

**예제: n=6, times=[7, 10]**

| 시간 T | 7분 심사대 | 10분 심사대 | 총 처리 인원 | 6명 가능? |
|--------|-----------|------------|-------------|----------|
| 10     | 10//7 = 1 | 10//10 = 1 | 2명         | ❌ 불가 |
| 20     | 20//7 = 2 | 20//10 = 2 | 4명         | ❌ 불가 |
| 28     | 28//7 = 4 | 28//10 = 2 | 6명         | ✅ 가능! |
| 27     | 27//7 = 3 | 27//10 = 2 | 5명         | ❌ 불가 |

**관찰:**
- 28분에서 처음으로 6명 처리 가능
- 27분 이하는 불가능
- → 답은 28!

**이분탐색 시뮬레이션:**
```
left=1, right=60 (10*6, 최악의 경우)

mid=30 → can_finish(30) = 6명 → 가능! → right=29, answer=30
mid=15 → can_finish(15) = 3명 → 불가 → left=16
mid=22 → can_finish(22) = 5명 → 불가 → left=23
mid=26 → can_finish(26) = 5명 → 불가 → left=27
mid=28 → can_finish(28) = 6명 → 가능! → right=27, answer=28
mid=27 → can_finish(27) = 5명 → 불가 → left=28

left > right 종료 → answer=28
```

---

### 6단계: 코드 구현 (이제는 기계적)

사고 과정이 명확하면 코드는 자연스럽게 나옴:

```python
def solution(n, times):
    # 1. 탐색 범위 설정
    left = 1                    # 최소: 1분
    right = min(times) * n      # 최악: 가장 빠른 심사대에서 모두 처리
    answer = right

    # 2. 이분탐색
    while left <= right:
        mid = (left + right) // 2

        # 3. 검증 함수: mid 시간에 n명 처리 가능한가?
        total = sum(mid // t for t in times)

        # 4. 이분탐색 로직
        if total >= n:           # 가능 → 더 작은 시간 탐색
            answer = mid
            right = mid - 1
        else:                    # 불가 → 더 큰 시간 필요
            left = mid + 1

    return answer
```

---

### 핵심 아이디어 (최종 정리)

1. **제약 조건이 알고리즘을 결정한다**: n ≤ 10억 → 시뮬레이션 불가
2. **질문을 바꿔라**: "최솟값 찾기" → "조건 만족 여부 판별"
3. **검증 함수를 먼저 만들어라**: `can_finish(time)`
4. **단조성 확인**: 시간이 늘면 처리 인원도 증가
5. **이분탐색으로 경계 찾기**: 가능/불가능의 경계점 = 답

### 접근 방법 (체계적 프로세스)

1. **제약 조건 확인** → 불가능한 접근 제거
2. **질문 변환** → 검증 함수로 바꾸기
3. **패턴 체크리스트** → 이분탐색 조건 확인
4. **손 시뮬레이션** → 작은 예제로 검증
5. **코드 구현** → 사고 과정을 그대로 옮김

## 회고

### 배운 점
(작성 전 - 문제 해결 후 작성)

### 어려웠던 부분
(작성 전 - 문제 해결 후 작성)

### 개선할 점
(작성 전 - 문제 해결 후 작성)

---

## 평가

### 현재 접근 방식 분석

solution.py의 주석을 보면 다음과 같은 사고 과정이 보입니다:

```python
# fanout 느낌인데 최솟값이 필요함
# 즉, n번을 시도하면서 각 시도마다 특정 심사원에 배정될때 발생되는 소요시간의 경우 의수
# 모든 경우의 수 중 최솟값이어야함
```

**문제점:**
1. **잘못된 접근 방향**: 그리디나 시뮬레이션으로 접근하려고 하고 있습니다
2. "각 사람을 어느 심사대에 배정할지"를 고민하고 있는데, 이는 **시간복잡도가 너무 큽니다**
3. n이 최대 1,000,000,000명까지 가능하므로 시뮬레이션은 불가능합니다

### 올바른 접근: 이분탐색 (Parametric Search)

이 문제는 **"최소 시간을 찾는 문제"**가 아니라, **"주어진 시간 안에 n명을 처리할 수 있는가?"**를 판별하는 문제로 바꿔 생각해야 합니다.

#### 핵심 통찰

1. **시간을 기준으로 이분탐색**
   - 최소 가능 시간: 1분
   - 최대 가능 시간: `min(times) * n` (가장 빠른 심사대에서 모든 사람 처리)

2. **특정 시간 t가 주어졌을 때, t분 안에 몇 명을 심사할 수 있는가?**
   ```python
   def can_process(time, times, n):
       total = 0
       for t in times:
           total += time // t  # 각 심사대에서 처리 가능한 인원
       return total >= n
   ```

3. **이분탐색으로 최소 시간 찾기**
   - `can_process(mid, times, n)`가 True이면 → 더 작은 시간도 가능한지 확인 (left ~ mid-1)
   - False이면 → 더 큰 시간이 필요 (mid+1 ~ right)

#### 구현 가이드

```python
def solution(n, times):
    left = 1
    right = min(times) * n  # 최악의 경우
    answer = right

    while left <= right:
        mid = (left + right) // 2

        # mid 시간 안에 심사 가능한 총 인원
        total = 0
        for time in times:
            total += mid // time

        if total >= n:  # n명 이상 처리 가능
            answer = mid
            right = mid - 1  # 더 작은 시간 탐색
        else:  # n명 처리 불가
            left = mid + 1  # 더 큰 시간 필요

    return answer
```

### 개선할 점 (실전 사고 훈련법)

#### 1. 문제 보자마자 체크리스트 돌리기 (5초 안에)

**즉시 확인할 3가지:**

```
[ ] 제약 조건 범위 확인
    n ≤ 10^9? → 시뮬레이션 불가
    배열 크기 ≤ 10^5? → O(N) 또는 O(N log N) 가능

[ ] 무엇을 구하는가?
    "최소/최대 값" → 이분탐색 후보
    "개수" → DP/조합론 후보
    "경로" → BFS/DFS 후보

[ ] 단조성이 있는가?
    "X가 가능하면 X+1도 가능" → 이분탐색!
```

**실전 훈련:**
- 문제 10개를 1분씩만 읽고 알고리즘 분류만 맞춰보기
- "왜 이 알고리즘인가?" 한 문장으로 설명하기

---

#### 2. "막혔다"는 신호 = "질문을 바꿔라"

**막혔을 때 던져볼 질문:**

| 막힌 상황 | 바꿔볼 질문 |
|-----------|------------|
| "최솟값을 어떻게 찾지?" | "값 X가 주어지면 가능한지 판별할 수 있나?" |
| "모든 경우를 확인해야 하나?" | "불가능한 경우를 먼저 제거할 수 있나?" |
| "그리디가 맞을까?" | "반례가 있나? 증명할 수 있나?" |

**실전 훈련:**
```python
# 문제를 만나면 먼저 이렇게 써보기
def can_solve_with_X(x):
    """X라는 값이 주어졌을 때, 조건을 만족하는가?"""
    # 이게 쉽게 구현된다면 → 이분탐색 가능!
    pass
```

---

#### 3. 파라메트릭 서치 패턴 암기 (템플릿화)

**매번 똑같은 구조:**

```python
def parametric_search(조건):
    # 1. 탐색 범위 설정
    left = 최솟값
    right = 최댓값
    answer = 초기값

    # 2. 이분탐색
    while left <= right:
        mid = (left + right) // 2

        # 3. 결정 함수 (핵심!)
        if can_solve(mid):
            answer = mid
            # 4. 최소를 찾는가? 최대를 찾는가?
            right = mid - 1  # 최소 찾기
            # left = mid + 1  # 최대 찾기
        else:
            left = mid + 1   # 최소 찾기
            # right = mid - 1  # 최대 찾기

    return answer
```

**실전 훈련:**
- 이 템플릿을 노트에 3번 손으로 쓰기
- 문제마다 `can_solve()` 함수만 채워넣는 연습

---

#### 4. 제약 조건 → 알고리즘 매핑표 만들기

| 제약 조건 | 가능한 복잡도 | 알고리즘 후보 |
|-----------|--------------|--------------|
| N ≤ 20 | O(2^N) | 완전탐색, 비트마스킹 |
| N ≤ 1,000 | O(N^2) | DP, 그래프 |
| N ≤ 100,000 | O(N log N) | 정렬, 이분탐색 |
| N ≤ 10^9 | O(log N) | **이분탐색, 수학** |

**이 문제:**
- n ≤ 10^9 → O(log N)만 가능 → **이분탐색 확정!**

**실전 훈련:**
- 이 표를 스크린샷 찍어 시험 시작 전에 보기
- 문제 보면 바로 "아, N이 10억이네? 이분탐색이구나" 자동 반사

---

#### 5. 손 시뮬레이션 습관화 (코드 쓰기 전!)

**절대 규칙: 코드 쓰기 전에 손으로 먼저!**

```
예제: n=6, times=[7, 10]

시간 28분이면?
→ 7분 심사대: 28÷7 = 4명
→ 10분 심사대: 28÷10 = 2명
→ 총 6명! ✅

시간 27분이면?
→ 7분 심사대: 27÷7 = 3명
→ 10분 심사대: 27÷10 = 2명
→ 총 5명... ❌

→ 깨달음: "28이 경계값이구나!"
→ 이분탐색으로 경계 찾으면 되겠다!
```

**실전 훈련:**
- 문제 풀 때 A4 용지 옆에 두고 반드시 손으로 쓰기
- "이게 왜 되는지" 말로 설명할 수 있어야 함

---

#### 6. "왜 이분탐색인가?" 체크리스트

**4가지 조건 모두 만족해야 함:**

```
✅ 범위가 크다 (10^6 이상)
✅ 단조성이 있다 (X 가능 → X+1도 가능)
✅ 검증 함수를 O(N) 이하로 구현 가능
✅ 최소/최대를 구하는 문제

→ 4개 다 체크? 이분탐색 99%!
```

**이 문제에 적용:**
- ✅ 시간 범위: 1 ~ 10^18 (매우 크다!)
- ✅ 단조성: 28분에 6명 가능 → 29분에도 6명 이상 가능
- ✅ 검증: `sum(time // t for t in times)` → O(N), N≤10만
- ✅ "최소 시간" 구하기

**실전 훈련:**
- 이 체크리스트를 문제지 여백에 쓰고 체크 표시하기
- 하나라도 안 맞으면? 다른 알고리즘 고민

---

#### 7. 비슷한 문제 패턴 정리 (근육 기억)

**"조건 만족하는 최솟값" 패턴:**

1. **입국심사** (이 문제): "n명 심사하는 최소 시간"
2. **징검다리 건너기**: "돌 k개 제거 후 최대 거리의 최솟값"
3. **예산**: "모두에게 예산 주되 최대값의 최솟값"
4. **랜선 자르기**: "N개 만들 수 있는 최대 길이"

**공통점:**
- 모두 "값을 정하면 → 조건 만족 여부 판별 가능"
- → 이분탐색!

**실전 훈련:**
- 이 4문제를 모두 풀어보기
- "아, 이 패턴이구나!" 느낌이 올 때까지 반복

### 잘한 점

1. **문제를 끝까지 고민하고 있는 점**
   - 주석으로 사고 과정을 기록하는 습관은 매우 좋습니다
   - "fanout", "경우의 수" 등 다양한 관점에서 접근하려는 시도가 보입니다

2. **막혔을 때 피드백을 구하는 태도**
   - 혼자 고민만 하기보다는 적절한 시점에 도움을 구하는 것이 학습에 효과적입니다

### 다른 응용 방안

이분탐색 + 결정 함수 패턴은 다음과 같은 문제에도 적용됩니다:

1. **"예산을 최대한 배분하되, 상한선 내에서"** → 상한선을 이분탐색
2. **"n개의 그룹으로 나누되, 각 그룹의 최대 합을 최소화"** → 최대 합을 이분탐색
3. **"배송 트럭의 최소 용량"** → 용량을 이분탐색하며 배송 가능 여부 판단

### 다른 추천 문제

1. **징검다리 건너기** (프로그래머스 Level 3)
   - 동일하게 파라메트릭 서치 패턴
   - "조건을 만족하는 최대 값" 찾기

2. **나무 자르기** (백준 2805)
   - 이분탐색 기본 문제
   - 결정 함수 구현 연습

3. **공유기 설치** (백준 2110)
   - "최대 거리의 최소값" 패턴
   - 이분탐색 + 그리디 조합

4. **랜선 자르기** (백준 1654)
   - 입국심사와 매우 유사한 구조
   - 이분탐색 워밍업용

### 종합 평가

#### 현재 상태 진단

**좋은 점:**
- 문제를 다각도로 고민하고 있음 (fanout, 경우의 수 등)
- 주석으로 사고 과정을 기록하는 습관
- 막혔을 때 도움을 구하는 태도

**문제점:**
- **제약 조건을 먼저 보지 않았음** ← 가장 큰 실수!
- n ≤ 10^9를 보고도 시뮬레이션을 시도
- "사람을 배정한다"는 직관에 갇힘
- 질문을 바꿔 생각하지 못함

---

#### 왜 이런 일이 발생했나?

**일반적인 문제 해결 순서 (잘못된 방법):**
```
1. 문제 읽기
2. 바로 구현 생각하기
3. 막히면... 다시 생각
4. 또 막히면... 포기 또는 질문
```

**올바른 문제 해결 순서:**
```
1. 문제 읽기
2. ⭐ 제약 조건부터 확인 (5초)
3. ⭐ 알고리즘 후보 좁히기 (10초)
4. ⭐ 작은 예제로 손 시뮬레이션 (1분)
5. 코드 작성 (5분)
```

**이 문제에서:**
- 2단계를 건너뛰어서 시뮬레이션 시도 → 막힘
- 만약 "n ≤ 10^9 → O(log N)만 가능 → 이분탐색!" 이 과정을 거쳤다면?
- → 5분 안에 풀림!

---

#### 앞으로 어떻게 할 것인가? (액션 플랜)

**즉시 실천 (오늘부터):**

1. **문제지에 이것부터 쓰기:**
   ```
   [ ] 제약 조건: N ≤ ?
   [ ] 가능한 복잡도: O(?)
   [ ] 알고리즘 후보: ?
   ```

2. **제약 조건 → 알고리즘 표 암기:**
   - N ≤ 20 → 완전탐색
   - N ≤ 1000 → O(N²) DP
   - N ≤ 100,000 → O(N log N) 정렬/이분탐색
   - **N ≤ 10^9 → O(log N) 이분탐색/수학**

3. **이분탐색 패턴 근육 기억:**
   - 추천 문제 4개를 이번 주 안에 풀기
   - 매번 "검증 함수 먼저 구현" 습관화

**단기 목표 (1주일):**

- [ ] 랜선 자르기 (백준 1654) - 워밍업
- [ ] 나무 자르기 (백준 2805) - 기본
- [ ] 공유기 설치 (백준 2110) - 응용
- [ ] 징검다리 건너기 (프로그래머스) - 심화

**장기 목표 (1개월):**

- 파라메트릭 서치를 보면 5초 안에 "아, 이분탐색이네" 자동 인식
- 검증 함수를 1분 안에 구현 가능
- "질문 바꾸기" 습관화: "최솟값 찾기" → "가능 여부 판별"

---

#### 핵심 교훈 (반드시 기억)

> **"코드를 쓰기 전에 제약 조건을 먼저 보라."**
> **"n ≤ 10^9 = 이분탐색 시그널"**
> **"막혔다 = 질문을 바꿔라"**

이 문제를 통해 배운 것은 단순히 "입국심사 문제 풀이"가 아닙니다.

**진짜 배운 것:**
1. 제약 조건이 알고리즘을 결정한다
2. 파라메트릭 서치 = 검증 함수 + 이분탐색
3. "찾기" 문제를 "판별" 문제로 변환하는 사고력

이제 위의 구현 가이드를 참고하여:
1. solution.py를 완성하고
2. `python3 test.py`로 테스트하고
3. 통과하면 "회고" 섹션에 **"내 언어로"** 정리해보세요

**중요:** 남의 말이 아닌, 직접 손으로 쓰고 말로 설명할 수 있어야 진짜 내 것입니다!

---
**복잡도**: O(N log M) (N: 심사대 개수, M: 이분탐색 범위)
**풀이 날짜**:
