# 스택
- 문제 번호: 10828
- 링크: https://www.acmicpc.net/problem/10828

```
#스택 #자료구조 #구현 #백준 #실버4
```

---

## 문제 설명

정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.

명령은 총 다섯 가지:
- `push X`: 정수 X를 스택에 넣는 연산
- `pop`: 스택에서 가장 위에 있는 정수를 빼고 출력. 스택이 비어있으면 -1 출력
- `size`: 스택에 들어있는 정수의 개수 출력
- `empty`: 스택이 비어있으면 1, 아니면 0 출력
- `top`: 스택의 가장 위에 있는 정수 출력. 스택이 비어있으면 -1 출력

## 제약 조건

- 1 ≤ N ≤ 10,000
- 1 ≤ X ≤ 100,000

---

## 풀이 과정

### 핵심 아이디어
- Python 리스트를 스택으로 활용
- 각 명령어를 조건문으로 분기 처리

### 접근 방법
1. 명령어 개수 N을 입력받고, N개의 명령어를 파싱
2. 각 명령어에 따라 스택 연산 수행
3. 출력이 필요한 명령어의 결과를 answer 리스트에 저장
4. 마지막에 한 번에 출력

## 회고

### 배운 점
-

### 어려웠던 부분
-

### 개선할 점
-

---

## 평가

### 개선할 점

1. **타입 불일치 문제**
   - `push`에서 `param = command_info[1]`로 문자열을 그대로 저장하고 있음
   - `pop`이나 `top`에서 반환할 때 문자열 "123"과 정수 -1이 혼재됨
   - 백준에서는 통과할 수 있지만, `int(command_info[1])`로 정수 변환하는 것이 명확함

2. **변수명 오타**
   - `anwser` → `answer`로 수정 필요
   - 오타는 코드 리뷰나 협업 시 혼란을 줄 수 있음

3. **입력 처리 방식**
   - `sys.stdin.readlines()`로 전체를 읽는 것은 좋으나, `map` 객체는 한 번만 순회 가능
   - 디버깅 시 재사용이 필요하면 `list()`로 변환하는 것이 안전

4. **출력 최적화**
   - 현재: 모든 결과를 리스트에 저장 후 `print(*answer, sep='\n')`
   - 대안: `'\n'.join(map(str, answer))`로 한 번에 출력하면 더 빠름
   - 또는 결과를 바로바로 출력하는 방식도 고려 가능

5. **주석 활용**
   - `# 입력 제한 N = 10000, 순회 가능`이라는 주석은 좋은 습관
   - 하지만 각 명령어 처리 부분에도 간단한 주석이 있으면 가독성 향상

### 잘한 점

1. **제약 조건 분석**
   - 주석에서 `N = 10000, 순회 가능`이라고 명시한 것은 복잡도를 미리 계산한 흔적
   - O(N) 풀이가 충분하다는 판단이 정확함

2. **효율적인 입력 처리**
   - `sys.stdin.readlines()`를 사용하여 빠른 입력 처리
   - 백준에서 시간 초과를 피하기 위한 좋은 패턴

3. **출력 최적화 시도**
   - `print(*answer, sep='\n')`로 한 번에 출력하여 I/O 횟수 최소화
   - 매번 `print()`를 호출하는 것보다 효율적

4. **명확한 조건 분기**
   - `if-elif` 구조로 각 명령어를 깔끔하게 분리
   - 스택이 비어있는 경우의 예외 처리가 잘 되어 있음

5. **Pythonic한 표현**
   - `if not stack`으로 빈 스택 체크
   - 삼항 연산자 `1 if not stack else 0` 활용

### 다른 응용 방안

- **딕셔너리를 활용한 명령어 처리**: if-elif 대신 함수 딕셔너리로 더 확장 가능한 구조
  ```python
  operations = {
      'push': lambda: stack.append(int(param)),
      'pop': lambda: answer.append(stack.pop() if stack else -1),
      ...
  }
  ```
- **클래스로 스택 구현**: 재사용 가능한 Stack 클래스로 구현하면 다른 문제에 활용 가능
- **deque 사용**: `collections.deque`는 양쪽 끝 연산이 O(1)이지만, 이 문제에서는 리스트로 충분

### 다른 추천 문제

- [9012 - 괄호](https://www.acmicpc.net/problem/9012): 스택 기본 활용 (올바른 괄호 판별)
- [4949 - 균형잡힌 세상](https://www.acmicpc.net/problem/4949): 여러 종류 괄호 매칭
- [1874 - 스택 수열](https://www.acmicpc.net/problem/1874): 스택으로 수열 만들기 (응용)
- [17298 - 오큰수](https://www.acmicpc.net/problem/17298): 스택 심화 (모노톤 스택)

---

## 종합 평가

스택의 기본 연산을 정확히 구현했으며, 입출력 최적화를 시도한 점이 좋습니다. 특히 주석에서 제약 조건을 분석한 흔적(`N = 10000, 순회 가능`)은 코딩 테스트에서 중요한 습관입니다.

그러나 몇 가지 아쉬운 점이 있습니다:

1. **타입 일관성**: push에서 문자열을 그대로 저장하는 것은 잠재적 버그의 원인이 됩니다. 비록 백준에서 통과하더라도, 정수로 변환하는 습관을 들이세요.

2. **변수명 오타**: `anwser`는 사소해 보이지만, 실제 코딩 테스트에서 오타로 인한 버그는 디버깅 시간을 크게 늘립니다.

3. **함수 호출 누락**: 원래 코드에서 `solution(commands)` 호출이 없었던 것은 치명적인 실수입니다. 코드 작성 후 반드시 실행 흐름을 점검하세요.

이 문제는 스택의 기본기를 다지는 문제이므로, 여기서 익힌 패턴을 바탕으로 괄호 매칭, 수식 계산 등 스택 응용 문제로 확장해 나가시기 바랍니다.

---

## 추가 학습

### 스택 자료구조 핵심 개념

**시간 복잡도**:
- push: O(1)
- pop: O(1)
- top/peek: O(1)
- size: O(1)
- empty: O(1)

**Python 리스트 vs deque**:
- 리스트: 끝에서의 연산 O(1), 시작에서의 연산 O(N)
- deque: 양쪽 끝 연산 모두 O(1)
- 스택(LIFO)만 필요하면 리스트로 충분

**백준 입출력 팁**:
```python
import sys
input = sys.stdin.readline  # 빠른 입력

# 여러 줄 출력 시
print('\n'.join(map(str, results)))  # 가장 빠름
```

---
**복잡도**: O(N) - N개의 명령어를 순회하며 각 명령어 O(1) 처리
**풀이 날짜**: 2025-11-19
