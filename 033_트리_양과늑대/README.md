# 양과 늑대
- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/92343

```
#트리 #BFS #상태공간탐색 #백트래킹
```

---

## 문제 설명

이진 트리 구조에서 각 노드에 양 또는 늑대가 있습니다. 루트 노드(0번)에서 시작하여 최대한 많은 양을 모으되, 어느 시점에서든 늑대의 수가 양의 수 이상이 되면 양들이 잡아먹힙니다. 모을 수 있는 양의 최댓값을 구하는 문제입니다.

## 문제 입출력

**입력:**
- `info`: 각 노드의 정보 (0: 양, 1: 늑대)
- `edges`: 트리의 간선 정보 [부모, 자식]

**출력:**
- 모을 수 있는 양의 최댓값

---

## 풀이 과정

### 핵심 아이디어
- **BFS + 상태 공간 탐색**: 각 상태를 (현재 위치, 양의 수, 늑대 수, 방문 가능한 노드 집합)으로 정의
- **핵심 제약**: 양의 수 > 늑대 수를 항상 유지해야 함
- **탐색 가능 노드 관리**: 현재까지 방문한 경로에서 갈 수 있는 모든 자식 노드를 집합으로 관리

### 접근 방법
1. 루트 노드(0번)에서 시작하여 BFS 탐색
2. 현재 노드의 자식 노드들을 "탐색 가능한 노드 집합"에 추가
3. 탐색 가능한 노드들 중에서 다음 노드를 선택할 때:
   - 늑대 노드라면: 양의 수 > 늑대 수 + 1 인 경우만 방문
   - 양 노드라면: 항상 방문 가능
4. 방문한 노드는 탐색 가능 집합에서 제거하고 새로운 상태로 큐에 추가
5. 모든 경로를 탐색하면서 최대 양의 수를 갱신

### 코드

```python
from collections import defaultdict, deque

def solution(info, edges):
    # 이진 트리 구조 생성
    tree = defaultdict(list)
    for [parent, child] in edges:
        tree[parent].append(child)

    # (현재 위치, 양의 수, 늑대의 수, 방문 가능한 노드 집합)
    queue = deque()
    queue.append((0, 1, 0, set()))

    max_sheeps = 0

    while queue:
        current, sheeps, wolfs, visited = queue.popleft()
        max_sheeps = max(max_sheeps, sheeps)

        # 현재 노드의 자식들을 방문 가능 집합에 추가
        visited.update(tree[current])

        # 방문 가능한 노드들 중 다음 노드 선택
        for next_node in visited:
            if info[next_node]:  # 늑대인 경우
                if sheeps <= wolfs + 1:
                    continue
                queue.append((next_node, sheeps, wolfs + 1, visited - {next_node}))
            else:  # 양인 경우
                queue.append((next_node, sheeps + 1, wolfs, visited - {next_node}))

    return max_sheeps
```

## 회고

### 배운 점
-

### 어려웠던 부분
-

### 개선할 점
-

## 평가

### 개선할 점

#### 1. **변수명 혼란: `visited`의 의미**
현재 코드에서 `visited` 변수는 "이미 방문한 노드"가 아니라 **"현재 시점에서 탐색 가능한 노드들의 집합"**을 의미합니다. 이는 일반적인 그래프 탐색에서 사용하는 visited의 의미와 정반대입니다.

**문제점:**
- 코드를 처음 읽는 사람이 혼란스러워함
- 알고리즘의 의도를 파악하기 어려움
- 본인도 주석에 "방문 여부라고 하니 이상하다"라고 언급 (solution.py:42)

**개선 제안:**
```python
# 현재 이름 (혼란스러움)
visited.update(tree[current])

# 제안 1: accessible_nodes
accessible_nodes = set()
accessible_nodes.update(tree[current])

# 제안 2: reachable (간결함)
reachable = set()
reachable.update(tree[current])

# 제안 3: candidates (의미 명확)
candidates = set()
candidates.update(tree[current])
```

**권장**: `reachable` 또는 `accessible_nodes` 사용

#### 2. **주석의 질문 형태**
코드에 "왜 ~하는거지?"와 같은 질문 형태의 주석이 남아있습니다 (32, 41번 줄). 이는 학습 과정에서 사고를 기록한 흔적인데, 최종 코드에서는 명확한 설명으로 바꾸는 것이 좋습니다.

**개선 예시:**
```python
# 현재 (질문 형태)
# 여기서왜 방문 처리를 미리하고 순회는 돌아버리는거지?

# 개선 (설명 형태)
# 현재 노드의 자식들을 탐색 가능 집합에 추가
# 이후 이 집합에서 조건에 맞는 노드를 선택하여 방문
```

#### 3. **테스트 케이스 미작성**
`test.py`에 실제 문제의 테스트 케이스가 없습니다. 프로그래머스 예제를 추가하면 로컬에서 검증 가능합니다.

```python
test_cases = [
    {
        "name": "예제 1",
        "input": ([0,0,1,1,1,0,1,0,1,0,1,1], [[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]]),
        "expected": 5,
    },
    {
        "name": "예제 2",
        "input": ([0,1,0,1,1,0,1,0,0,1,0], [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]]),
        "expected": 5,
    },
]
```

#### 4. **복잡도 분석 누락**
README에 시간/공간 복잡도가 명시되지 않았습니다.

**복잡도**:
- 시간: O(2^N × N) - 최악의 경우 모든 노드 방문 순서 조합 탐색
- 공간: O(2^N × N) - 큐에 저장되는 상태의 수

---

### 잘한 점

#### 1. **올바른 알고리즘 선택**
이 문제는 단순 DFS/BFS로 풀 수 없고, **상태 공간 탐색**이 필요합니다. 각 상태를 `(위치, 양, 늑대, 탐색가능노드)`로 정의한 것이 핵심입니다.

#### 2. **효율적인 집합 연산**
```python
visited.update(tree[current])  # 자식 노드 추가
visited - {next_node}  # 방문한 노드 제거
```
집합의 `update()`와 차집합 연산(`-`)을 활용하여 코드가 간결하고 효율적입니다.

#### 3. **사고 과정의 기록**
주석으로 생각의 흐름을 기록한 것은 매우 좋은 습관입니다. 특히 "왜 이렇게 하는가?"를 고민한 흔적이 보입니다. 단, 최종 정리 시 설명 형태로 바꾸면 더 좋습니다.

#### 4. **엣지 케이스 처리**
늑대 노드 방문 시 `sheeps <= wolfs + 1` 조건으로 양이 잡아먹히는 상황을 정확히 방지했습니다.

---

### 다른 응용 방안

#### 1. **게임 트리 탐색 (Minimax)**
- 체스, 오목 등의 게임 AI에서 승리 확률을 최대화하는 경로 탐색
- 각 상태: (보드 상태, 점수, 다음 턴 플레이어)

#### 2. **배낭 문제의 변형**
- 제약 조건이 있는 최적화 문제
- 상태: (현재 무게, 현재 가치, 남은 아이템)

#### 3. **미로 탈출 + 아이템 수집**
- 미로에서 아이템을 최대한 수집하며 탈출
- 상태: (위치, 수집한 아이템 집합, 남은 체력)

#### 4. **주식 매매 최적화**
- 여러 제약 조건 하에서 최대 수익 계산
- 상태: (현재 날짜, 보유 주식, 잔고, 거래 가능 여부)

---

### 다른 추천 문제

#### 유사 문제 (상태 공간 탐색)
- **[프로그래머스] 등굣길** (Level 3) - DP + 제약 조건
- **[프로그래머스] 도둑질** (Level 4) - 원형 구조 + DP
- **[백준] 14502 연구소** - 조합 + BFS

#### 트리 탐색 심화
- **[프로그래머스] 길 찾기 게임** (Level 3) - 이진 트리 구성
- **[백준] 1167 트리의 지름** - 트리 DFS 응용
- **[백준] 2533 사회망 서비스(SNS)** - 트리 DP

#### 백트래킹 + 상태 관리
- **[백준] 9663 N-Queen** - 백트래킹 기본
- **[백준] 1987 알파벳** - 백트래킹 + 집합 관리

---

### 종합 평가

이 풀이는 **상태 공간 탐색**의 핵심 개념을 정확히 이해하고 구현했습니다. 특히 "탐색 가능한 노드 집합"을 상태에 포함시킨 것이 문제 해결의 핵심이며, 이를 BFS로 모든 경우를 탐색하는 접근이 올바릅니다.

다만 **변수명 선택의 중요성**을 간과했습니다. `visited`라는 이름은 그래프 탐색에서 거의 표준처럼 사용되는 용어이기 때문에, 반대 의미로 사용하면 코드 가독성이 크게 떨어집니다. 실제로 본인도 주석에서 "이름이 이상하다"고 지적했는데, 이는 코드를 작성하는 중에도 혼란을 느꼈다는 신호입니다.

**명명의 중요성**: 알고리즘 문제 풀이에서 변수명은 단순히 "의미 전달"을 넘어 **사고의 명확성**을 결정합니다. 혼란스러운 이름은 디버깅을 어렵게 하고, 실수를 유발하며, 코드 리뷰나 면접 상황에서 부정적인 인상을 줍니다. `reachable`, `accessible_nodes`, `candidates` 등 의미가 명확한 이름을 선택하는 습관을 들이세요.

코드의 로직은 완벽하지만, **코드는 컴퓨터뿐만 아니라 사람도 읽는다**는 점을 기억하세요. 특히 코딩 테스트 면접에서는 면접관이 코드를 읽고 이해하는 속도가 평가에 직접적인 영향을 미칩니다.

마지막으로, **테스트 케이스 작성**을 습관화하세요. 로컬에서 검증하는 과정은 디버깅 시간을 크게 줄이고, 엣지 케이스를 발견하는 데 필수적입니다.

---

### 추가 학습: 상태 공간 탐색 (State Space Search)

#### 개념
**상태 공간 탐색**은 문제의 모든 가능한 상태를 탐색하여 최적해를 찾는 기법입니다. 각 상태는 문제를 풀기 위한 필수 정보를 포함합니다.

#### 이 문제에서의 상태 설계
```python
(current, sheeps, wolfs, reachable)
```
- `current`: 현재 위치 (어디에 있는가?)
- `sheeps, wolfs`: 모은 양과 늑대 수 (무엇을 가지고 있는가?)
- `reachable`: 탐색 가능한 노드 집합 (어디로 갈 수 있는가?)

#### 왜 `reachable`이 필요한가?
일반적인 트리 탐색과 달리, 이 문제는 **한 번 방문한 노드로 돌아가서 다른 경로를 선택**할 수 있습니다. 예를 들어:

```
      0(양)
     / \
    1   2
   (늑대)(양)
```

1. 0 → 1 → 2 (가능)
2. 0 → 2 → 1 (가능)

같은 노드를 방문하더라도 **어떤 순서로 왔는가**에 따라 결과가 달라집니다. 따라서 "이미 방문한 노드"를 체크하는 일반적인 visited 방식이 아니라, **현재 상태에서 갈 수 있는 노드 집합**을 관리해야 합니다.

#### 상태 공간 탐색 vs 일반 DFS/BFS

| 구분 | 일반 DFS/BFS | 상태 공간 탐색 |
|------|-------------|---------------|
| visited | 노드 단위 | 상태 단위 |
| 중복 방문 | 불가능 | 다른 상태로 가능 |
| 상태 정의 | 단순 (위치만) | 복잡 (위치 + 추가 정보) |
| 예시 | 최단 경로 | 제약 조건 하의 최적화 |

#### 다른 예시: 배낭 문제
```python
# 상태: (현재 아이템 인덱스, 남은 무게)
state = (i, remaining_weight)
```

각 상태마다 "현재 아이템을 넣는다/넣지 않는다" 두 가지 선택이 가능하며, 모든 상태를 탐색하여 최대 가치를 찾습니다.

---

**복잡도**: O(2^N × N)
**풀이 날짜**: 2025-01
