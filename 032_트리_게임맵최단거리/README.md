# 게임 맵 최단거리
- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/1844

```
#BFS #최단경로 #그래프탐색
```

---

## 문제 설명

ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.

지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: n, 열: m) 위치에 있습니다.

게임 캐릭터는 **상, 하, 좌, 우 네 방향**으로 한 칸씩 이동할 수 있으며, 게임 맵을 벗어난 곳으로는 이동할 수 없습니다.

아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.
- 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.
- 두 번째 방법은 15개의 칸을 지나서 상대 팀 진영에 도착했습니다.

위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.

만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다.

게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 **칸의 개수의 최솟값**을 return 하도록 solution 함수를 작성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.

### 제한사항
- maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
- n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.
- maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
- 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.

## 문제 입출력

### 입출력 예

| maps | answer |
|------|--------|
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] | 11 |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] | -1 |

### 입출력 예 설명

**입출력 예 #1**
- 주어진 데이터는 다음과 같습니다.
```
1 0 1 1 1
1 0 1 0 1
1 0 1 1 1
1 1 1 0 1
0 0 0 0 1
```
- 캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 11칸을 지나가는 것입니다.

**입출력 예 #2**
- 주어진 데이터는 다음과 같습니다.
```
1 0 1 1 1
1 0 1 0 1
1 0 1 1 1
1 1 1 0 0
0 0 0 0 1
```
- 8행 4열의 0이 추가되어, 캐릭터가 적 팀의 진영에 도착할 수 없습니다. 따라서 -1을 return 합니다.

---

## 풀이 과정

### 핵심 아이디어
- BFS를 사용한 최단 경로 탐색
- 시작점 (0,0)에서 도착점 (width-1, height-1)까지의 최소 이동 횟수 계산

### 접근 방법
1. 큐에 시작점과 이동 거리(1)를 저장
2. 큐에서 위치를 꺼내어 도착점인지 확인
3. 4방향으로 이동 가능한 위치를 탐색하여 큐에 추가
4. 방문한 위치는 set으로 관리하여 중복 방문 방지
5. 모든 탐색을 완료했는데 도착하지 못하면 -1 반환

## 회고

### 배운 점
-

### 어려웠던 부분
-

### 개선할 점
-

## 평가

## 개선할 점

### 1. 시작점 방문 처리 누락 (solution.py:31)
```python
# 현재 코드
queue.append((0,0,1))
while queue:
    # ...

# 개선안
queue.append((0,0,1))
visited.add((0,0))  # 시작점도 방문 처리
while queue:
    # ...
```
- 시작점 (0,0)을 큐에 넣었지만 visited에 추가하지 않았습니다.
- 이 문제에서는 시작점으로 다시 돌아오는 경로가 최단 경로가 될 수 없어 큰 영향은 없지만, **엄밀한 BFS 구현을 위해서는 시작점도 방문 처리**를 해야 합니다.
- 다른 문제에서 순환 경로가 가능한 경우 무한 루프나 중복 탐색이 발생할 수 있습니다.

### 2. 도착 지점 체크 시점 최적화 가능
```python
# 현재: 큐에서 꺼낸 후 도착 체크
x, y, moves = queue.popleft()
if x == width-1 and y == height-1:
    return moves

# 개선안: 큐에 넣기 전에 도착 체크
if nx == width-1 and ny == height-1:
    return moves + 1

queue.append((nx, ny, moves+1))
```
- 현재는 도착 지점을 큐에 넣고 다음 반복에서 꺼내어 확인합니다.
- 큐에 넣기 전에 확인하면 불필요한 큐 삽입/삭제 연산을 줄일 수 있습니다.
- 다만 코드의 가독성 측면에서 현재 방식도 충분히 명확합니다.

### 3. 코드 주석이 다소 장황함
```python
# 현재
# 큐에서 이동 정보를 가져옵니다
# 현재 위치가 도착지라면 이동 거리와 함께 종료
# 이동 정보를 토대로 4방향을 탐색
# 각 방향으로 이동 가능하면  방문 여부 및 큐에 저장
```
- 주석이 코드보다 많아 오히려 가독성을 떨어뜨릴 수 있습니다.
- 핵심 로직에만 간결한 주석을 다는 것이 좋습니다.

## 잘한 점

### 1. BFS 알고리즘의 정확한 구현
- 최단 경로 문제에 BFS를 적용한 것이 완벽한 선택입니다.
- 큐를 사용한 레벨 순회로 첫 도착이 곧 최단 경로임을 보장합니다.

### 2. 방문 처리 시점이 올바름
```python
# 큐에 추가하기 직전에 방문 처리
visited.add((nx,ny))
queue.append((nx,ny,moves+1))
```
- 방문 처리를 큐 삽입 전에 하여 **중복 큐 삽입을 방지**했습니다.
- 이는 BFS 성능 최적화의 핵심 기법입니다.

### 3. 튜플을 활용한 효율적인 자료구조
```python
visited = set()  # (x, y) 튜플 저장
queue = deque()  # (x, y, moves) 튜플 저장
```
- 별도의 클래스 없이 튜플만으로 깔끔하게 구현했습니다.
- set을 사용한 O(1) 방문 체크는 매우 효율적입니다.

### 4. 명확한 조건 체크
```python
if not (0 <= nx < width and 0 <= ny < height):
    continue
```
- 경계 체크, 벽 체크, 방문 체크를 명확히 분리하여 가독성이 좋습니다.
- Pythonic한 방식의 조건문 작성이 돋보입니다.

### 5. 방향 벡터의 활용
```python
directions = [(-1,0),(1,0),(0,-1),(0,1)]
```
- 4방향 이동을 깔끔하게 처리했습니다.
- 이 패턴은 다른 그래프 탐색 문제에도 재사용 가능합니다.

## 다른 응용 방안

### 1. 최단 경로 복원
현재는 거리만 반환하지만, 실제 경로를 복원할 수도 있습니다:
```python
# 각 노드의 부모 저장
parent = {}
parent[(0,0)] = None

# BFS 탐색 중
parent[(nx,ny)] = (x,y)

# 경로 복원
path = []
curr = (width-1, height-1)
while curr:
    path.append(curr)
    curr = parent[curr]
path.reverse()
```

### 2. 가중치가 있는 그래프로 확장
각 칸마다 이동 비용이 다르다면 다익스트라 알고리즘으로 확장:
```python
import heapq
pq = [(0, 0, 0)]  # (비용, x, y)
```

### 3. 다중 도착점 문제
여러 개의 도착점 중 가장 가까운 곳 찾기:
```python
goals = [(5,5), (7,7), (9,9)]
if (x,y) in goals:
    return moves
```

## 다른 추천 문제

### 기본 BFS 최단 경로
- **[백준] 2178번 미로 탐색** - 가장 기본적인 BFS 최단 경로
- **[백준] 7576번 토마토** - 다중 시작점 BFS
- **[백준] 7569번 토마토 3D** - 3차원 BFS

### 조건부 BFS
- **[프로그래머스] 미로 탈출** - 레버를 당겨야 하는 조건이 있는 BFS (이미 풀이 완료)
- **[백준] 1697번 숨바꼭질** - 1차원 BFS
- **[백준] 13549번 숨바꼭질 3** - 0-1 BFS (가중치가 0 또는 1)

### 다익스트라로 확장
- **[백준] 4485번 녹색 옷 입은 애가 젤다지?** - 가중치가 있는 2D 최단 경로
- **[프로그래머스] 배달** - 가중치 그래프 최단 경로

### 상태 공간 탐색
- **[백준] 1194번 달이 차오른다, 가자.** - 열쇠와 문이 있는 미로 (비트마스킹)
- **[백준] 14442번 벽 부수고 이동하기 2** - K개의 벽을 부술 수 있는 경우

## 종합 평가

전반적으로 BFS 알고리즘을 정확하게 이해하고 깔끔하게 구현한 풀이입니다. 특히 방문 처리를 큐 삽입 전에 하여 중복 탐색을 방지한 점, 튜플과 set을 활용한 효율적인 자료구조 선택이 우수합니다.

다만 몇 가지 개선할 점이 있습니다:
1. **시작점 방문 처리**: 시작점도 visited에 추가하는 것이 엄밀한 BFS 구현입니다. 이 습관을 들이면 다른 문제에서 발생할 수 있는 버그를 예방할 수 있습니다.
2. **주석의 간결성**: 과도한 주석은 오히려 가독성을 떨어뜨립니다. 핵심 로직에만 간결하게 주석을 다는 연습을 하세요.
3. **조기 종료 최적화**: 도착 지점 체크를 큐에 넣기 전에 하면 불필요한 연산을 줄일 수 있습니다.

이 문제는 BFS의 기본을 다지는 좋은 문제입니다. 다음 단계로는 **조건부 BFS**(레버, 열쇠 등 상태 관리) 또는 **가중치가 있는 그래프**(다익스트라) 문제를 도전해보시길 추천합니다. 특히 백준 1194번 "달이 차오른다, 가자"는 이 문제의 심화 버전으로, 비트마스킹을 활용한 상태 관리를 배울 수 있는 좋은 문제입니다.

---
**복잡도**: O(N × M) - 최악의 경우 모든 칸을 한 번씩 방문
**풀이 날짜**: 2024-11-16

---

## 추가 학습

### BFS의 핵심 원리

BFS(Breadth-First Search, 너비 우선 탐색)는 **레벨 단위로 탐색**하는 알고리즘입니다.

#### 왜 BFS가 최단 경로를 보장하는가?

```python
# 레벨별 탐색 순서
레벨 0: 시작점 (0,0) - 거리 1
레벨 1: (0,0)에서 1칸 이동 가능한 모든 점 - 거리 2
레벨 2: 레벨 1에서 1칸 이동 가능한 모든 점 - 거리 3
...
```

- BFS는 **가까운 노드부터 순서대로 방문**합니다.
- 따라서 목적지에 **처음 도착한 순간이 곧 최단 거리**입니다.
- 이는 **모든 간선의 가중치가 동일**(여기서는 1)할 때만 성립합니다.

#### BFS vs DFS 비교

| 특징 | BFS | DFS |
|------|-----|-----|
| 자료구조 | 큐 (Queue) | 스택 (Stack) 또는 재귀 |
| 탐색 방식 | 레벨 순회 (가로로) | 깊이 우선 (세로로) |
| 최단 경로 | ✅ 보장 (가중치 1) | ❌ 보장 안 됨 |
| 메모리 | 넓게 퍼질수록 많이 사용 | 깊이만큼 사용 |
| 적용 문제 | 최단 거리, 최소 이동 | 경로 존재 여부, 백트래킹 |

### BFS 구현의 핵심 패턴

#### 1. 방문 처리 시점

```python
# ❌ 잘못된 방법: 큐에서 꺼낼 때 방문 처리
while queue:
    x, y = queue.popleft()
    if (x, y) in visited:
        continue
    visited.add((x, y))  # 큐에서 꺼낸 후 방문 처리

    # → 같은 노드가 큐에 여러 번 들어갈 수 있음 (비효율)

# ✅ 올바른 방법: 큐에 넣기 전 방문 처리
while queue:
    x, y = queue.popleft()

    for nx, ny in neighbors:
        if (nx, ny) in visited:
            continue
        visited.add((nx, ny))  # 큐에 넣기 전 방문 처리
        queue.append((nx, ny))

    # → 같은 노드가 큐에 단 한 번만 들어감 (효율적)
```

#### 2. 거리 추적 방법

**방법 1: 큐에 거리 포함** (이 문제의 풀이 방식)
```python
queue.append((x, y, distance))
```
- 장점: 간단하고 직관적
- 단점: 메모리 사용량이 약간 증가

**방법 2: 별도 배열에 거리 저장**
```python
dist = [[float('inf')] * width for _ in range(height)]
dist[0][0] = 1
queue.append((0, 0))

while queue:
    x, y = queue.popleft()
    for nx, ny in neighbors:
        if dist[ny][nx] == float('inf'):
            dist[ny][nx] = dist[y][x] + 1
            queue.append((nx, ny))
```
- 장점: 메모리 효율적, 경로 복원 가능
- 단점: 코드가 약간 복잡

#### 3. 2D 그래프의 좌표 표현

```python
# 주의: maps[y][x] vs (x, y)
# maps는 2D 배열 → maps[행][열] = maps[y][x]
# 좌표는 (x, y) 형태 → x는 열, y는 행

# 올바른 접근
x, y = 3, 2
value = maps[y][x]  # maps[2][3] ✅

# 잘못된 접근
value = maps[x][y]  # maps[3][2] ❌
```

### 다양한 BFS 변형

#### 1. 다중 시작점 BFS
여러 지점에서 동시에 시작:
```python
queue = deque()
for start in start_points:
    queue.append((*start, 0))
    visited.add(start)
```
- 예: 토마토 문제 (여러 익은 토마토가 동시에 퍼짐)

#### 2. 0-1 BFS
가중치가 0 또는 1인 경우 deque 양쪽 삽입:
```python
from collections import deque
dq = deque([(0, 0, 0)])

while dq:
    cost, x, y = dq.popleft()

    for nx, ny, weight in neighbors:
        new_cost = cost + weight
        if weight == 0:
            dq.appendleft((new_cost, nx, ny))  # 비용 0은 앞에
        else:
            dq.append((new_cost, nx, ny))      # 비용 1은 뒤에
```

#### 3. 양방향 BFS
시작점과 도착점에서 동시에 탐색:
```python
queue1 = deque([start])  # 시작점에서 출발
queue2 = deque([end])    # 도착점에서 출발
visited1, visited2 = set(), set()

# 두 탐색이 만나면 최단 경로 발견
```

### 핵심 개념 정리

1. **BFS는 가중치가 1일 때 최단 경로를 보장** - 가중치가 다르면 다익스트라 사용
2. **방문 처리는 큐 삽입 전에** - 중복 큐 삽입 방지로 성능 향상
3. **2D 좌표는 (x, y)이지만 배열 접근은 [y][x]** - 혼동 주의
4. **deque를 사용** - list의 pop(0)은 O(n)이지만 deque.popleft()는 O(1)
5. **시작점도 방문 처리** - 순환 경로가 있는 문제에서 중요
