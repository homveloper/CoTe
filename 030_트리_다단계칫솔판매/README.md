# 다단계 칫솔 판매
- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/77486

```
#트리 #해시테이블 #그래프 #시뮬레이션
```

## 풀이 과정

### 핵심 아이디어
- 트리 구조에서 리프 노드부터 루트까지 수익을 분배하는 상향식(bottom-up) 접근
- 각 판매원이 수익의 10%를 추천인에게 전달하고, 1원 미만은 절삭하여 본인이 보유
- 해시테이블로 부모-자식 관계를 O(1)에 조회

### 접근 방법
1. `enroll`과 `referral`을 zip하여 각 조직원의 추천인(부모) 매핑 딕셔너리 생성
2. 각 판매원의 판매 기록(`seller`, `amount`)을 순회하며:
   - 판매 금액 = 수량 × 100원
   - 현재 판매원부터 부모를 따라 루트('-')까지 올라가며:
     - 현재 조직원의 수익: `income - income // 10` (90%)
     - 부모에게 전달할 금액: `income // 10` (10%)
3. `enroll` 순서대로 각 조직원의 누적 수익 반환

## 회고

### 배운 점
-

### 어려웠던 부분
-

### 개선할 점
-

---

## 평가

### 개선할 점

1. **조기 종료 최적화 누락**
   ```python
   while current != '-':
       incomes[current] += income - income // 10
       current = parents[current]
       income //= 10
   ```
   현재 코드는 `income`이 0이 되어도 루트까지 계속 순회합니다. 문제 조건에 따라 "1원 미만인 경우 분배를 중단"해야 하므로, `income < 1`일 때 `break`하면 불필요한 반복을 줄일 수 있습니다.

   **개선안**:
   ```python
   while current != '-' and income >= 1:
       profit = income - income // 10
       incomes[current] += profit
       income //= 10
       current = parents[current]
   ```

2. **주석 정리**
   - 1~8번 줄의 주석은 문제 이해를 위한 메모로 보이지만, 실제 코드에는 필요 없습니다.
   - 핵심 로직에만 간결한 주석을 남기는 것이 가독성에 좋습니다.

3. **변수명 개선**
   - `person` → `seller_name` (판매원과 조직원을 구분)
   - `current` → `member` (현재 처리 중인 조직원 명시)

4. **엣지 케이스 처리 명시**
   - `parents.get(current)`에서 KeyError 가능성은 없지만, 안전성을 위해 `.get(current, '-')`로 명시적 기본값 사용 고려

### 잘한 점

1. **적절한 자료구조 선택**
   - `defaultdict(int)`로 초기화 없이 수익 누적 가능
   - Dictionary comprehension으로 부모-자식 관계를 O(1) 조회

2. **간결한 로직 구현**
   - `zip(seller, amount)`로 동시 순회
   - `income //= 10`으로 10% 계산과 다음 반복 준비를 한 번에 처리
   - 정수 나눗셈(`//`)으로 소수점 절삭 자동 처리

3. **시뮬레이션 정확성**
   - 트리를 따라 올라가며 수익을 분배하는 과정을 명확히 구현
   - `income - income // 10` (90%)과 `income // 10` (10%) 계산이 정확함

4. **효율적인 결과 생성**
   - `enroll` 순서대로 결과를 생성하여 별도 정렬 불필요

### 다른 응용 방안

1. **MLM(Multi-Level Marketing) 수수료 계산 시스템**
   - 추천인 단계별로 차등 수수료율 적용 (예: 1단계 10%, 2단계 5%, 3단계 2%)
   - 최대 깊이 제한이 있는 수익 분배 시뮬레이션

2. **회사 조직도 기반 인센티브 계산**
   - 팀 성과에 따라 상위 관리자까지 성과급 분배
   - 특정 임계값 이상일 때만 상위 전파 (조기 종료 최적화 활용)

3. **추천인 시스템 포인트 적립**
   - 사용자 활동에 따른 추천인 리워드 분배
   - 트리 깊이별 가중치 적용

4. **블록체인 스테이킹 보상 분배**
   - 위임자(delegator)와 검증자(validator) 간 보상 분배
   - 수수료율이 다른 다단계 분배 시스템

### 다른 추천 문제

1. **[프로그래머스] 부모 찾기** (트리 구조 탐색)
   - 트리에서 특정 노드의 부모를 찾는 기본 문제
   - 해시테이블 기반 부모-자식 관계 매핑 연습

2. **[프로그래머스] 가장 먼 노드** (BFS, 그래프)
   - 트리/그래프에서 루트로부터의 거리 계산
   - 레벨별 탐색과 거리 누적 패턴 학습

3. **[프로그래머스] 길 찾기 게임** (이진 트리, 순회)
   - 트리 구조 생성 및 전위/후위 순회
   - 트리 구조를 직접 만들고 활용하는 고급 문제

4. **[백준] 트리의 부모 찾기 (11725번)**
   - 루트가 주어진 트리에서 각 노드의 부모 찾기
   - DFS/BFS를 활용한 트리 탐색 기본

5. **[백준] 사회망 서비스(SNS) (2533번)**
   - 트리 DP 문제
   - 상향식 계산 패턴과 트리 구조의 결합

### 종합 평가

이 풀이는 **트리 구조에서의 상향식(bottom-up) 탐색과 수익 분배 로직을 정확히 구현**한 좋은 코드입니다.

**강점**은 `defaultdict`와 dictionary comprehension으로 간결하게 자료구조를 구성하고, `while` 루프 하나로 부모를 따라 올라가며 수익을 분배하는 핵심 로직을 명확히 표현했다는 점입니다. 특히 `income //= 10`으로 다음 반복을 준비하는 부분이 효율적입니다.

**개선 포인트**는 성능 최적화입니다. 현재 코드는 `income`이 0이 되어도 루트까지 계속 순회하는데, **문제 조건("1원 미만인 경우 분배 중단")**을 활용하면 불필요한 반복을 줄일 수 있습니다. 최악의 경우 트리 깊이가 깊다면 의미 없는 연산이 누적될 수 있으므로, `income >= 1` 조건을 추가하는 것이 좋습니다.

또한 코딩 테스트에서는 **코드 가독성**도 중요합니다. 1~8번 줄의 장황한 주석은 제출 전에 제거하고, 핵심 로직에만 간결한 주석을 남기는 습관을 들이면 좋겠습니다. 변수명도 `person` 대신 `seller_name`, `current` 대신 `member` 등으로 명확히 하면 의도가 더 잘 전달됩니다.

**시간복잡도**는 O(S × H) (S: 판매 건수, H: 트리 평균 깊이), **공간복잡도**는 O(N) (N: 조직원 수)로 효율적입니다. 조기 종료를 추가하면 평균 케이스에서 더 빠른 실행이 가능합니다.

이 문제는 트리 구조를 해시테이블로 표현하고 상향식으로 탐색하는 패턴을 학습하기에 좋은 문제입니다. 실무에서도 MLM 수수료, 조직도 인센티브, 추천인 리워드 등 다양하게 응용 가능한 유용한 알고리즘입니다.

---

## 추가 학습

### 1. 트리 상향식(Bottom-Up) vs 하향식(Top-Down) 탐색

이 문제는 **리프 노드(판매원)에서 루트(최상위)로 올라가는 상향식 탐색**을 사용합니다.

- **상향식(Bottom-Up)**: 자식 → 부모 방향으로 정보 전달
  - 예: 판매 수익이 발생한 노드부터 부모로 올라가며 분배
  - 활용: DP (작은 문제 → 큰 문제), 트리 합 계산

- **하향식(Top-Down)**: 부모 → 자식 방향으로 정보 전달
  - 예: 루트에서 시작하여 각 자식에게 정보 전파
  - 활용: DFS, 트리 순회, 최단 경로

### 2. 정수 나눗셈을 활용한 수수료 계산 패턴

```python
# 10% 계산 및 소수점 절삭
parent_share = income // 10  # 10% (정수 나눗셈으로 자동 버림)
my_share = income - parent_share  # 90% (1원 미만 절삭금 포함)
```

이 패턴은 금융/수수료 계산에서 자주 사용됩니다:
- 환전 수수료 계산 (소수점 버림)
- 세금 계산 (원 단위 절사)
- 포인트 적립 (1포인트 미만 버림)

### 3. 조기 종료 최적화 (Early Termination)

```python
while current != '-' and income >= 1:  # 1원 미만이면 중단
    ...
```

**효과**:
- 최선의 경우: O(1) (첫 분배에서 1원 미만)
- 평균적인 경우: 트리 깊이의 절반 정도에서 중단
- 최악의 경우: O(H) (루트까지 계속 분배)

**적용 가능한 문제**:
- 이진 탐색 (목표값 발견 시 중단)
- DFS/BFS (특정 조건 만족 시 탐색 중단)
- DP (이미 계산된 값 재사용)

### 4. 해시테이블 기반 트리 표현

```python
parents = {child: parent for child, parent in zip(enroll, referral)}
```

**장점**:
- O(1) 부모 조회 (배열은 O(N) 탐색 필요)
- 노드 번호가 아닌 이름(문자열) 사용 가능
- 동적으로 노드 추가/삭제 용이

**활용 사례**:
- Union-Find (Disjoint Set)에서 부모 찾기
- 그래프 인접 리스트 표현
- 계층 구조 (조직도, 파일 시스템)

### 5. defaultdict 활용

```python
from collections import defaultdict
incomes = defaultdict(int)  # 초기값 0
```

**장점**:
- `if key not in dict` 검사 불필요
- 초기화 코드 간소화
- 코드 가독성 향상

**다른 활용**:
- `defaultdict(list)`: 그룹화 (단어 길이별 분류 등)
- `defaultdict(set)`: 중복 제거 (인접 리스트 등)

---
**복잡도**: O(S × H) (S: 판매 건수, H: 트리 평균 깊이)
**공간복잡도**: O(N) (N: 조직원 수)
**풀이 날짜**: 2025-11-15
