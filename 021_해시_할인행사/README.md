# [할인 행사]
- 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/131127

```
#해시 #슬라이딩윈도우 #딕셔너리
```

## 문제 설명

XYZ 마트는 일정한 기간 동안 회원 대상으로 매일 한 가지 제품을 할인하는 행사를 합니다.
정현이는 자신이 원하는 제품과 수량이 할인하는 날짜와 10일 연속으로 일치할 경우에 맞춰서 회원가입을 하려 합니다.

예를 들어, 정현이가 원하는 제품이 바나나 3개, 사과 2개, 쌀 2개, 돼지고기 2개, 냄비 1개이며,
XYZ 마트에서 14일간 회원을 대상으로 할인하는 제품이 다음과 같을 때:
- 1일: 치킨, 2일: 사과, 3일: 사과, 4일: 바나나, 5일: 쌀, 6일: 사과, 7일: 돼지고기
- 8일: 바나나, 9일: 돼지고기, 10일: 쌀, 11일: 냄비, 12일: 바나나, 13일: 사과, 14일: 바나나

정현이가 원하는 제품을 모두 할인 받을 수 있는 회원등록 날짜의 총 일수는 3일입니다.

**입력**:
- `want`: 정현이가 원하는 제품 배열
- `number`: 정현이가 원하는 제품의 수량 배열
- `discount`: XYZ 마트에서 할인하는 제품 배열 (날짜 순서)

**출력**:
- 회원등록 시 정현이가 원하는 제품을 모두 할인 받을 수 있는 회원등록 날짜의 총 일수

**제약조건**:
- 1 ≤ want 길이 = number 길이 ≤ 10
- 1 ≤ number 원소 ≤ 10
- 10 ≤ discount 길이 ≤ 100,000
- 회원등록 후 **연속 10일** 동안 할인 적용

## 풀이 과정

### 핵심 아이디어
- 슬라이딩 윈도우를 이용하여 연속된 10일 구간을 순회
- 각 구간의 할인 품목을 딕셔너리로 카운팅하여 원하는 품목과 비교

### 접근 방법
1. 전체 일수를 일정 주기(10일) 만큼 순회 하면서 각 구간의 할인 품목을 카운팅
2. 원하는 품목의 전체 수량과 비교하여 일치하는지 확인

## 회고

### 배운 점
- 컴프리헨시브 딕셔너리 생성 방법을 사용하지 않고도 dict() 와 zip()을 활용하여 깔끔하게 딕셔너리를 생성할 수 있음

### 어려웠던 부분
- 문제의 내용을 정확하게 파악하지 못해서, 입출력을 보고도 왜 그런 결과가 나오는지 이해하는 데 시간이 걸렸음

### 개선할 점
- 문제의 요구사항과 조건을 파악하기 위해서 예시가 어떻게 동작하는지 꼼꼼히 살펴볼 것

## 평가

### 문제 이해가 어려웠던 이유 분석

이 문제가 어려웠던 가장 큰 이유는 **"연속된 10일" 개념**과 **"슬라이딩 윈도우"**를 요구한다는 점입니다.

**문제 핵심 요약**:
```
원하는 상품: ['banana', 'apple', 'rice', 'pork', 'pot']
원하는 개수: [3, 2, 2, 2, 1]

할인 일정: ['chicken', 'apple', 'apple', 'banana', 'rice', 'apple',
           'pork', 'banana', 'pork', 'rice', 'pot', 'banana',
           'apple', 'banana']

질문: "연속된 10일 동안" 원하는 모든 상품을 정확한 개수만큼 살 수 있는 날짜는?
```

**왜 입출력이 그렇게 나오는가?**

테스트케이스 1을 자세히 분석:
```
Day 0부터 시작: [0~9일]
  chicken(1), apple(3), banana(1), rice(1), pork(1), pot(0) → X (pot 없음)

Day 1부터 시작: [1~10일]
  apple(3), banana(2), rice(2), pork(2), pot(1) → ✓ (정확히 일치!)

Day 2부터 시작: [2~11일]
  apple(3), banana(3), rice(2), pork(2), pot(1) → X (banana 3개는 2개가 필요)

Day 3부터 시작: [3~12일]
  banana(3), rice(2), apple(2), pork(2), pot(1) → X (apple 2개는 3개가 필요)

Day 4부터 시작: [4~13일]
  rice(2), apple(3), pork(2), banana(3), pot(1) → ✓ (정확히 일치!)

... (이런 식으로 계속)

총 3일 가능 → 정답: 3
```

**핵심 조건**:
1. **연속된 10일** - 중간에 하루라도 끊기면 안 됨
2. **정확한 개수** - 3개 필요한데 2개나 4개 있으면 안 됨 (딱 맞아야 함)
3. **모든 상품** - 하나라도 부족하면 안 됨

### 개선할 점

1. **제출용 코드에 print문 제거**
   - `print(discount_dict)` (line 19)는 디버깅용입니다
   - 프로그래머스 제출 시 불필요한 출력으로 시간 초과 가능성

2. **슬라이딩 윈도우 최적화 가능**
   - 현재: 매번 10개 항목을 다시 카운팅 → O(n*10)
   - 개선: 하나 빼고 하나 추가 → O(n)
   ```python
   # 첫 윈도우 구성
   discount_dict = {}
   for i in range(10):
       discount_dict[discount[i]] = discount_dict.get(discount[i], 0) + 1

   # 슬라이딩
   for i in range(1, len(discount) - 9):
       # 왼쪽 하나 제거
       old = discount[i-1]
       discount_dict[old] -= 1
       if discount_dict[old] == 0:
           del discount_dict[old]

       # 오른쪽 하나 추가
       new = discount[i+9]
       discount_dict[new] = discount_dict.get(new, 0) + 1
   ```

3. **Counter 사용으로 가독성 향상**
   ```python
   from collections import Counter

   want_dict = dict(zip(want, number))
   for i in range(len(discount) - 9):
       discount_dict = Counter(discount[i:i+10])
       if want_dict == discount_dict:
           result += 1
   ```

4. **경계 조건 명확화**
   - `range(len(discount) - 9)` → 왜 -9인가?
   - 마지막 윈도우가 `[len-10, len-1]`이므로 시작점은 `len-10`까지
   - 주석으로 설명 추가 권장

### 잘한 점

1. **dict.get() 활용**
   - `discount_dict.get(food, 0)` 사용으로 KeyError 방지
   - 초기화와 증가를 한 줄로 처리

2. **zip() 활용**
   - `dict(zip(want, number))`로 깔끔하게 딕셔너리 생성
   - 두 리스트를 매핑하는 파이썬다운 방식

3. **딕셔너리 비교**
   - `want_dict == discount_dict`로 한 줄에 조건 체크
   - 키와 값 모두 비교하는 정확한 방법

4. **문제 패턴 파악**
   - 해설을 보고 슬라이딩 윈도우 + 해시 카운팅 패턴 학습
   - 이 패턴은 매우 자주 나오는 중요한 유형

### 다른 응용 방안

1. **Anagram 찾기**
   ```
   문자열 s에서 패턴 p의 모든 anagram 위치 찾기
   예: s="cbaebabacd", p="abc" → [0, 6] (cba, bac)
   ```
   동일한 슬라이딩 윈도우 + Counter 비교 사용

2. **최소 윈도우 부분 문자열**
   ```
   s에서 t의 모든 문자를 포함하는 최소 길이 부분 문자열
   예: s="ADOBECODEBANC", t="ABC" → "BANC"
   ```
   가변 크기 슬라이딩 윈도우 + 카운팅

3. **연속된 K일 최대 매출**
   ```
   매출 배열에서 연속된 k일의 최대 합
   예: [100, 200, 300, 400], k=2 → 700
   ```
   숫자 합계 버전의 슬라이딩 윈도우

4. **DNA 서열 분석**
   ```
   DNA 문자열에서 특정 패턴이 몇 번 나타나는지
   예: "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT", 10글자 윈도우
   ```
   생물정보학에서 실제로 사용

### 종합 평가

**문제 이해의 어려움은 매우 자연스러운 과정**입니다. 이 문제의 핵심 난이도는:

1. **"연속된 10일" 조건 파악** - 문제에서 명시했지만 눈치채기 어려움
2. **"정확히 일치" 요구사항** - 이상/이하가 아닌 정확한 개수
3. **슬라이딩 윈도우 패턴 인식** - 이 유형을 처음 접하면 접근법 자체가 떠오르지 않음

**해설을 보고 이해했다는 것 자체가 중요한 학습**입니다. 코딩 테스트에서 가장 중요한 것은:
- ❌ 처음 본 문제를 30분 안에 풀기
- ✅ 유형을 학습하고 다음에는 풀 수 있게 되기

**현재 구현의 긍정적 측면**:
- 핵심 로직(윈도우 카운팅 + 딕셔너리 비교)을 정확히 구현했습니다
- dict.get(), zip() 등 파이썬 관용구를 잘 활용했습니다
- 코드가 직관적이고 읽기 쉽습니다

**다음 학습 단계**:
1. 슬라이딩 윈도우 최적화 (O(n*k) → O(n)) 직접 구현해보기
2. Counter 모듈 사용법 익히기
3. 유사 문제 3~5개 더 풀어보기 (Anagram, 부분 문자열 등)
4. "연속된 K개" 키워드가 나오면 슬라이딩 윈도우 떠올리기

**중요한 깨달음**:
문제를 못 푼 이유는 실력 부족이 아니라 **"이 유형을 처음 봤기 때문"**입니다.
해설을 통해 패턴을 학습했으니, 이제 이 유형은 여러분의 무기가 되었습니다.
다음에 "연속된 N개" 문제를 만나면 자신있게 슬라이딩 윈도우로 접근할 수 있을 것입니다!

---
**복잡도**: O(n * 10) → 최적화 시 O(n), n은 discount 배열 길이
**풀이 날짜**: 2025-11-10
