# [방문길이]
- [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/49994)

#구현 #방향 #중복처리

## 풀이 과정

### 핵심 아이디어
- 이동 중복 여부는 set 자료구조를 활용하여 처리
- set은 유니크하므로  set의 길이로 중복 없는 경로 수 파악 가능

### 접근 방법
1. 방향 순회
2. 이동 가능 여부 확인
3. 이동 경로를 set에 추가
   1. 이동 경로는 방향이 없으므로, (출발점, 도착점), (도착점, 출발점) 모두 추가
4. 최종적으로 set의 길이 반환
5. 이동 경로는 왕복이므로 2로 나누기

## 회고

### 배운 점
- set 자료구조의 유용성
- 함수에서 tuple 반환 및 언패킹 활용법

### 어려웠던 부분
- 이동 경로를 어떻게 표현할지 고민

### 개선할 점
-

---
**복잡도**: O(N)
**풀이 날짜**: 2025-10-29

---

## 코드 리뷰 평가

### 🔍 개선이 필요한 부분

1. **비효율적인 경로 저장 방식**
   - 양방향 경로를 각각 저장한 뒤 2로 나누는 방식은 불필요한 메모리 낭비
   - `visited`에 실제 필요한 것의 2배 데이터를 저장하고 있음
   - 정렬된 tuple이나 frozenset을 사용하면 하나의 entry로 관리 가능

2. **확장성이 떨어지는 방향 처리**
   - `nextPosition`의 if 체인은 방향이 추가될 때마다 함수 수정 필요
   - 현재 구조로는 대각선 이동, 3D 공간 확장 시 코드 중복 발생
   - 데이터와 로직이 섞여 있어 유지보수가 어려움

3. **매직 넘버 하드코딩**
   - `-5`, `5`, `0`, `2` 등의 숫자가 코드에 직접 박혀있음
   - 좌표 평면의 크기가 변경되면 여러 곳을 수정해야 함
   - 상수로 분리하여 관리하는 것이 바람직

### ✅ 구조적 개선 방안

**1. 메모리 효율적인 경로 저장**
```python
# 현재 방식 (문제있음)
visited.add((cx, cy, nx, ny))
visited.add((nx, ny, cx, cy))  # 중복 저장
return len(visited) // 2

# 개선안 1: 정렬된 tuple 사용
edge = tuple(sorted([(cx, cy), (nx, ny)]))
visited.add(edge)
return len(visited)

# 개선안 2: frozenset 사용 (더 명확함)
visited.add(frozenset([(cx, cy), (nx, ny)]))
return len(visited)
```
→ 메모리 사용량 50% 감소, 나누기 연산 불필요

**2. 확장 가능한 방향 처리**
```python
# 현재 방식 (문제있음)
def nextPosition(x, y, dir):
    if dir == 'U': return x, y+1
    if dir == 'D': return x, y-1
    # ... 방향 추가마다 함수 수정 필요

# 개선안: 데이터 주도 설계
DIRECTIONS = {
    'U': (0, 1), 'D': (0, -1),
    'R': (1, 0), 'L': (-1, 0)
}

def nextPosition(x, y, dir):
    dx, dy = DIRECTIONS[dir]  # 코테에서는 예외 처리 불필요
    return x + dx, y + dy
```
→ 대각선 이동, 3D 확장 시 DIRECTIONS만 수정
→ 코테에서는 입력이 항상 유효하므로 예외 처리 생략 가능

**3. 명확한 상수 관리**
```python
# 현재 방식 (문제있음)
def validPosition(x, y):
    return (-5 <= x <= 5) and (-5 <= y <= 5)

# 개선안
GRID_MIN, GRID_MAX = -5, 5

def validPosition(x, y):
    return (GRID_MIN <= x <= GRID_MAX) and (GRID_MIN <= y <= GRID_MAX)
```
→ 좌표 범위 변경 시 한 곳만 수정


### 💡 다른 활용 아이디어

1. **3D 공간 확장**
   - 현재 2D 평면 문제를 3D 공간(x, y, z)으로 확장 가능
   - 방향에 'F'(앞), 'B'(뒤) 추가
   - `validPosition`에 z 범위 체크 추가

2. **대각선 이동 지원**
   - 'UL', 'UR', 'DL', 'DR' 등 대각선 방향 추가
   - DIRECTIONS dictionary에 8방향 정의

3. **가중치 그래프 응용**
   - 각 경로에 가중치(거리, 비용)를 부여
   - `visited`를 dict로 변경하여 `{경로: 가중치}` 저장
   - 최단 거리 문제로 확장 가능

4. **시각화**
   - matplotlib로 이동 경로를 그래프로 표현
   - 방문한 경로를 색상으로 구분하여 표시

### 🎯 복잡도 분석

**시간 복잡도**: O(N) ✓ (정확함)
- N = dirs의 길이
- 각 명령어마다 O(1) 연산 수행 (set add, 좌표 계산)

**공간 복잡도**: O(N)
- 최악의 경우 모든 이동이 새로운 경로
- visited set에 최대 2N개 entry 저장 (양방향 저장)

### 📊 종합 평가

기본적인 알고리즘 이해도는 충분하나, 코드 설계 관점에서 개선이 필요합니다.

**설계 문제**: 양방향 경로를 2배로 저장하는 방식은 근본적으로 비효율적입니다. frozenset이나 정렬된 tuple로 하나의 경로만 저장하면 메모리를 절반으로 줄이고 나누기 연산도 제거할 수 있습니다. "일단 동작하게 만들고 나중에 최적화"가 아니라, 처음부터 올바른 자료구조를 선택하는 습관이 필요합니다.

**확장성 부족**: if 체인으로 방향을 처리하는 것은 전형적인 안티패턴입니다. 새로운 방향이 추가되면 함수를 매번 수정해야 하고, 이는 OCP(개방-폐쇄 원칙) 위반입니다. 데이터 주도 설계로 DIRECTIONS를 분리하면 로직 변경 없이 확장 가능합니다.

**매직 넘버**: `-5`, `5` 같은 하드코딩된 값들이 산재해 있습니다. 이 문제에서는 범위가 고정되어 있어 큰 문제는 아니지만, 비슷한 패턴의 문제를 여러 개 풀 때 상수로 관리하면 실수를 줄일 수 있습니다.

시간복잡도는 최적이지만, 코드 구조 개선으로 더 나은 풀이가 될 수 있습니다. 특히 양방향 경로를 2배로 저장하는 방식은 메모리 측면에서 명백한 비효율이므로, frozenset이나 정렬된 tuple을 사용하는 것을 권장합니다. 방향 처리도 dictionary로 바꾸면 코드가 더 간결하고 확장 가능해집니다.
